  private static SonarComponents createSonarComponentsMock(SensorContextTester contextTester) {

    CheckFactory checkFactory = mock(CheckFactory.class);
    Checks<Object> checks = mock(Checks.class);
    when(checks.addAnnotatedChecks(any(Collection.class))).thenReturn(checks);
    when(checks.ruleKey(any(JavaCheck.class))).thenReturn(RuleKey.of("squid", RuleAnnotationUtils.getRuleKey(BadMethodNameCheck.class)));

    JavaTestClasspath javaTestClasspath = mock(JavaTestClasspath.class);
    when(javaTestClasspath.getElements()).thenReturn(ImmutableList.of());

    JavaClasspath javaClasspath = mock(JavaClasspath.class);
    when(javaClasspath.getElements()).thenReturn(ImmutableList.of());
    when(checkFactory.create(anyString())).thenReturn(checks);

    FileLinesContext fileLinesContext = mock(FileLinesContext.class);
    FileLinesContextFactory fileLinesContextFactory = mock(FileLinesContextFactory.class);
    when(fileLinesContextFactory.createFor(any(InputFile.class))).thenReturn(fileLinesContext);
    ResourcePerspectives resourcePerspectives = mock(ResourcePerspectives.class);
    Symbolizable symbolizable = mock(Symbolizable.class);
    when(resourcePerspectives.as(eq(Symbolizable.class), any(InputFile.class))).thenReturn(symbolizable);
    when(symbolizable.newSymbolTableBuilder()).thenReturn(mock(Symbolizable.SymbolTableBuilder.class));
    SonarComponents sonarComponents = spy(new SonarComponents(fileLinesContextFactory, resourcePerspectives, contextTester.fileSystem(), javaClasspath, javaTestClasspath, checkFactory));
    sonarComponents.setSensorContext(contextTester);

    BadMethodNameCheck check = new BadMethodNameCheck();
    when(sonarComponents.checkClasses()).thenReturn(new CodeVisitor[]{check});
    return sonarComponents;
  }

