  @Override
  public boolean isMatching(List<Token> tokens) {
    Set<Rule> ruleCandidates = Sets.newHashSet(rules);
    Token nextCommonPatternMatcherTokenToMatch = getNextCommonPatternMatcherTokenToMatch();

    int prefixMatchTokens = 0;
    for (Token token : tokens) {
      if (getNextCommonPatternMatcherComparator().compare(token, nextCommonPatternMatcherTokenToMatch) == 0) {
        ImmutableSet.Builder<Rule> mismatchingRules = ImmutableSet.builder();

        for (Rule ruleCandidate : ruleCandidates) {
          PrefixParser.PrefixParseResult prefixParseResult = prefixParser.parse(ruleCandidate, tokens.subList(0, prefixMatchTokens));

          if (prefixParseResult == PrefixParseResult.MISMATCH) {
            mismatchingRules.add(ruleCandidate);
          } else if (prefixParseResult == PrefixParseResult.FULL_MATCH &&
            getNextPatternMatcher().isMatching(tokens.subList(prefixMatchTokens, tokens.size()))) {

            return true;
          }
        }

        ruleCandidates.removeAll(mismatchingRules.build());

        if (ruleCandidates.isEmpty()) {
          break;
        }
      }

      prefixMatchTokens++;
    }

    return false;
  }

