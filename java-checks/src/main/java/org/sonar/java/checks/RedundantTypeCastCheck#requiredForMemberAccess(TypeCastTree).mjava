  private static boolean requiredForMemberAccess(TypeCastTree typeCastTree) {
    ExpressionTree expression = typeCastTree.expression();
    if (!expression.is(Tree.Kind.METHOD_INVOCATION)) {
      Tree parent = typeCastTree.parent();
      return expression.is(Tree.Kind.METHOD_REFERENCE) && parent != null && skipParentheses(parent).is(Tree.Kind.MEMBER_SELECT);
    }
    Symbol symbol = ((MethodInvocationTree) expression).symbol();
    if (!symbol.isMethodSymbol()) {
      return false;
    }
    // consider REQUIRED as soon as the parent expression is a member access (killing the noise), without checking if cast could have been avoided
    // as the member accessed could have also been part of initial type
    return skipParentheses(typeCastTree.parent()).is(Tree.Kind.MEMBER_SELECT);
  }

