  @Override
  public void visitNode(Tree tree) {
    if (!hasSemantic()) {
      return;
    }
    MethodTree methodTree = (MethodTree) tree;
    if (methodTree.block() == null || isExcluded(methodTree)) {
      return;
    }
    Set<String> documentedParameters = documentedParameters(methodTree);
    boolean overridableMethod = overridableMethod(methodTree.symbol());
    List<IdentifierTree> unused = Lists.newArrayList();
    for (VariableTree var : methodTree.parameters()) {
      Symbol symbol = var.symbol();
      if (symbol.usages().isEmpty()
        && !symbol.metadata().isAnnotatedWith(AUTHORIZED_ANNOTATION)
        && !isStrutsActionParameter(var)
        && (!overridableMethod || !documentedParameters.contains(symbol.name()))) {
        unused.add(var.simpleName());
      }
    }
    Set<String> unresolvedIdentifierNames = unresolvedIdentifierNames(methodTree.block());
    // kill the noise regarding unresolved identifiers, and remove the one with matching names from the list of unused
    unused = unused.stream()
      .filter(id -> !unresolvedIdentifierNames.contains(id.name()))
      .collect(Collectors.toList());
    if (!unused.isEmpty()) {
      reportUnusedParameters(unused);
    }
  }

