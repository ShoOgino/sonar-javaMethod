  @Override
  public void visitClass(ClassTree tree) {
    if (tree.is(Tree.Kind.CLASS)) {
      Symbol.TypeSymbolSemantic typeSymbol = tree.symbol();
      if (typeSymbol != null && typeSymbol.isAbstract()) {
        Collection<Symbol> symbols = typeSymbol.memberSymbols();
        int abstractMethod = countAbstractMethods(symbols);
        //only count "this" in symbols and not "super" because abstract classes extending cannot be converted to interface
        if (symbols.size() == 1 || abstractMethod == symbols.size() - 1) {
          //emtpy abstract class or only abstract method
          context.addIssue(tree, ruleKey, "Convert this \"" + typeSymbol + "\" class to an interface");
        }
        if (symbols.size() > 1 && abstractMethod == 0 && !isPartialImplementation(tree)) {
          //Not empty abstract class with no abstract method
          context.addIssue(tree, ruleKey, "Convert this \"" + typeSymbol + "\" class to a concrete class with a private constructor");
        }
      }
    }
    super.visitClass(tree);
  }

