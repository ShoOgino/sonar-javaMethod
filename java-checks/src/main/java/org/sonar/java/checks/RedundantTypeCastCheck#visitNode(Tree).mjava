  @Override
  public void visitNode(Tree tree) {
    if(!hasSemantic()) {
      return;
    }
    TypeCastTree typeCastTree = (TypeCastTree) tree;
    Type cast = typeCastTree.type().symbolType();
    Type target = targetType(typeCastTree);
    Type expressionType = typeCastTree.expression().symbolType();
    if(isPrimitiveWrapperInConditional(expressionType, typeCastTree)) {
      // Excluded because covered by S2154
      return;
    }
    if(target != null && (isRedundantNumericalCast(cast, expressionType) || isSubtype(expressionType, target))) {
      reportIssue(typeCastTree.type(), "Remove this unnecessary cast to \"" + cast + "\".");
    }
  }

