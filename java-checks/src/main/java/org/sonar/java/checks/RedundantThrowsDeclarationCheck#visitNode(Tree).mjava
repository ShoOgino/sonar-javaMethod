  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    ListTree<TypeTree> thrownList = methodTree.throwsClauses();

    Set<Type> thrownExceptions = thrownExceptionsFromBody(methodTree);
    boolean hasTryWithResourceInBody = hasTryWithResourceInBody(methodTree);

    Set<String> reported = new HashSet<>();
    for (TypeTree typeTree : thrownList) {
      Type exceptionType = typeTree.symbolType();
      if (hasTryWithResourceInBody && (exceptionType.is("java.io.IOException") || exceptionType.is("java.lang.Exception"))) {
        // method 'close()' from 'java.lang.AutoCloseable' interface throws 'java.lang.Exception'
        // method 'close()' from 'java.io.Closeable' interface throws 'java.io.IOException"
        continue;
      }
      String fullyQualifiedName = exceptionType.fullyQualifiedName();
      if (!reported.contains(fullyQualifiedName)) {
        String superTypeName = isSubclassOfAny(exceptionType, thrownList);
        if (superTypeName != null) {
          reportIssue(typeTree, String.format("Remove the declaration of thrown exception '%s' which is a subclass of '%s'.", fullyQualifiedName, superTypeName));
        } else if (exceptionType.isSubtypeOf("java.lang.RuntimeException")) {
          reportIssue(typeTree, String.format("Remove the declaration of thrown exception '%s' which is a runtime exception.", fullyQualifiedName));
        } else if (declaredMoreThanOnce(fullyQualifiedName, thrownList)) {
          reportIssue(typeTree, String.format("Remove the redundant '%s' thrown exception declaration(s).", fullyQualifiedName));
        } else if (canNotBeThrown(methodTree, exceptionType, thrownExceptions)) {
          reportIssue(typeTree, String.format("Remove the declaration of thrown exception '%s', as it cannot be thrown from %s's body.", fullyQualifiedName,
            methodTreeType(methodTree)));
        }
        reported.add(fullyQualifiedName);
      }
    }
  }

