  private static Optional<String> matchFunctionalInterface(Type type) {
    JavaType javaType = (JavaType) type;
    if (!javaType.isParameterized()) {
      return Optional.empty();
    }
    ParametrizedTypeJavaType ptjt = (ParametrizedTypeJavaType) javaType;
    switch (ptjt.getSymbol().getFullyQualifiedName()) {
      case "java.util.function.Function":
        return handleFunctionInterface(ptjt);
      case "java.util.function.BiFunction":
        return handleBiFunctionInterface(ptjt);
      case "java.util.function.BiConsumer":
        return handleBiConsumerInterface(ptjt);
      case "java.util.function.Supplier":
        return handleSupplier(ptjt);
      case "java.util.function.Consumer":
      case "java.util.function.Predicate":
      case "java.util.function.UnaryOperator":
      case "java.util.function.BinaryOperator":
        return Optional.ofNullable(new ParameterTypeNameAndTreeType(ptjt, 0).paramTypeName).map(s -> s + javaType.name());
      default:
        return Optional.empty();
    }
  }

