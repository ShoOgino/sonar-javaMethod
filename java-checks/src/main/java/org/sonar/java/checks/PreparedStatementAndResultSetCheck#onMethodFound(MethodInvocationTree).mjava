  @Override
  protected void onMethodFound(MethodInvocationTree mit) {
    Integer methodFirstArgumentAsInteger = LiteralUtils.intLiteralValue(mit.arguments().get(0));
    if (methodFirstArgumentAsInteger == null) {
      // nothing to say if first argument can not be evaluated
      return;
    }

    boolean isMethodFromJavaSqlResultSet = mit.symbol().owner().type().is(JAVA_SQL_RESULTSET);
    int methodFirstArgumentValue = methodFirstArgumentAsInteger.intValue();

    if (isMethodFromJavaSqlResultSet && methodFirstArgumentValue == 0) {
      addIssue(mit, "ResultSet indices start at 1.");
    } else if (!isMethodFromJavaSqlResultSet) {
      if (methodFirstArgumentValue == 0) {
        addIssue(mit, "PreparedStatement indices start at 1.");
      } else {
        Tree preparedStatementReference = getPreparedStatementReference(mit);
        Integer numberParameters = getNumberParametersFromPreparedStatement(preparedStatementReference);
        if (numberParameters != null && methodFirstArgumentValue > numberParameters.intValue()) {
          addIssue(mit, "This \"PreparedStatement\" " + (numberParameters == 0 ? "has no" : ("only has " + numberParameters)) + " parameters.");
        }
      }
    }
  }

