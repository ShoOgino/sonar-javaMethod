  @CheckForNull
  private static Type targetType(TypeCastTree typeCastTree) {
    Tree parent = skipParentheses(typeCastTree.parent());

    switch (parent.kind()) {
      case RETURN_STATEMENT:
        Tree method = parent;
        while (!method.is(Tree.Kind.METHOD, Tree.Kind.LAMBDA_EXPRESSION)) {
          method = method.parent();
        }
        if (method.is(Tree.Kind.METHOD)) {
          MethodTree methodTree = (MethodTree) method;
          Type type = methodTree.symbol().type();
          if (type instanceof MethodJavaType) {
            return ((MethodJavaType) type).resultType();
          }
          return methodTree.symbol().returnType().type();
        }
        return null;
      case VARIABLE:
        return ((VariableTree) parent).symbol().type();
      case METHOD_INVOCATION:
        // FIXME(SONARJAVA-3191) dead code
        // If placed in invocation arguments, parent of typecast will be ARGUMENTS, not METHOD_INVOCATION
        MethodInvocationTree mit = (MethodInvocationTree) parent;
        if (mit.symbol().isMethodSymbol()) {
          Symbol.MethodSymbol sym = (Symbol.MethodSymbol) mit.symbol();
          int castArgIndex = mit.arguments().indexOf(typeCastTree);
          return sym.parameterTypes().get(castArgIndex);
        }
        return null;
      case MEMBER_SELECT:
      case CONDITIONAL_EXPRESSION:
        return typeCastTree.type().symbolType();
      case ARRAY_ACCESS_EXPRESSION:
        return ((ArrayAccessExpressionTree) parent).expression().symbolType();
      default:
        if (parent instanceof ExpressionTree) {
          return ((ExpressionTree) parent).symbolType();
        }
        return null;
    }
  }

