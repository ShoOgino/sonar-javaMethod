  @CheckForNull
  private static Type targetType(TypeCastTree typeCastTree) {
    Tree parent = skipParentheses(typeCastTree.parent());

    switch (parent.kind()) {
      case RETURN_STATEMENT:
        Tree method = parent;
        while (!method.is(Tree.Kind.METHOD, Tree.Kind.LAMBDA_EXPRESSION)) {
          method = method.parent();
        }
        if (method.is(Tree.Kind.METHOD)) {
          return ((MethodTree) method).symbol().returnType().type();
        }
        return null;
      case VARIABLE:
        return ((VariableTree) parent).symbol().type();
      case ARGUMENTS:
        Arguments arguments = (Arguments) parent;
        Tree invocation = arguments.parent();
        if (invocation.is(Tree.Kind.METHOD_INVOCATION)) {
          return targetTypeFromMethodSymbol(((MethodInvocationTree) invocation).symbol(), arguments, typeCastTree);
        }
        if (invocation.is(Tree.Kind.NEW_CLASS)) {
          return targetTypeFromMethodSymbol(((NewClassTree) invocation).constructorSymbol(), arguments, typeCastTree);
        }
        // Last possible case is AnnotationTree which we do not consider
        return null;
      case MEMBER_SELECT:
      case CONDITIONAL_EXPRESSION:
        return typeCastTree.type().symbolType();
      case ARRAY_ACCESS_EXPRESSION:
        return ((ArrayAccessExpressionTree) parent).expression().symbolType();
      default:
        if (parent instanceof ExpressionTree) {
          return ((ExpressionTree) parent).symbolType();
        }
        return null;
    }
  }

