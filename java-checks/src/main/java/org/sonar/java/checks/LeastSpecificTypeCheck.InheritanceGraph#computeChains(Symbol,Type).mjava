    private List<List<Type>> computeChains(Symbol m, Type type) {
      Symbol.TypeSymbol typeSymbol = type.symbol();
      Set<ClassJavaType> superTypes = ((JavaSymbol.TypeJavaSymbol) typeSymbol).directSuperTypes();
      List<List<Type>> result = new ArrayList<>();
      for (ClassJavaType superType : superTypes) {
        for (List<Type> chain : computeChains(m, superType)) {
          chain.add(type);
          result.add(chain);
        }
      }

      boolean definesSymbol = definesSymbol(m, typeSymbol);
      boolean isSpecialization = !((JavaType) startType).isParameterized() && ((JavaType) type).isParameterized();
      if (definesSymbol && !isSpecialization && result.isEmpty()) {
        result.add(Lists.newArrayList(type));
      }
      return result;
    }

