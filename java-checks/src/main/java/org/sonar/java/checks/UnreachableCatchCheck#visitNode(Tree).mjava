  @Override
  public void visitNode(Tree tree) {
    TryStatementTree tryStatementTree = (TryStatementTree) tree;
    if (!tryStatementTree.resourceList().isEmpty()) {
      // Try with resource will call close, throwing by default an Exception or IOException.
      // Supporting potential problems is not worth since it is really unlikely that something wrong happen.
      return;
    }
    typeToCatchToken.clear();
    Multimap<Type, Type> baseToDerived = getBaseTypeCaughtAfterDerivedType(tryStatementTree.catches());

    if (baseToDerived.isEmpty()) {
      return;
    }

    ThrownExceptionCollector collector = new ThrownExceptionCollector();
    tryStatementTree.block().accept(collector);
    List<Type> thrownTypes = collector.thrownTypes;

    baseToDerived.asMap().forEach((baseType, derivedTypes) -> {
      List<Type> derivedTypesHiding = derivedTypes.stream()
        .filter(derivedType -> isHiding(derivedType, thrownTypes))
        .collect(Collectors.toList());

      if (!derivedTypesHiding.isEmpty()) {
        reportIssue(typeToCatchToken.get(baseType),
          "Remove this catch block because it is unreachable as hidden by previous catch blocks.",
          derivedTypesHiding.stream().map(type -> new JavaFileScannerContext.Location("Already catch the exception", typeToCatchToken.get(type)))
          .collect(Collectors.toList()),
          null);
      }
    });
  }

