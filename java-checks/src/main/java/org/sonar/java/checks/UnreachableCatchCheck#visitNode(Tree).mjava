  @Override
  public void visitNode(Tree tree) {
    TryStatementTree tryStatementTree = (TryStatementTree) tree;
    if (!tryStatementTree.resourceList().isEmpty()) {
      // Try with resource will call close, throwing by default an Exception or IOException.
      // Supporting potential problems is not worth since it is really unlikely that something wrong happen.
      return;
    }
    Map<Type, Tree> typeToTypeTree = new HashMap<>();
    Multimap<Type, Type> baseToDerived = getBaseTypeCaughtAfterDerivedType(tryStatementTree.catches(), typeToTypeTree);

    if (baseToDerived.isEmpty()) {
      return;
    }

    ThrownExceptionCollector collector = new ThrownExceptionCollector();
    tryStatementTree.block().accept(collector);

    if (collector.unknownVisited || collector.thrownTypes.isEmpty()) {
      // Unknown method can throw anything, we can not tell anything about it.
      return;
    }

    List<Type> thrownTypes = collector.thrownTypes;

    baseToDerived.asMap().forEach((baseType, derivedTypes) -> {
      List<Type> derivedTypesHiding = derivedTypes.stream()
        .filter(derivedType -> isHiding(derivedType, thrownTypes))
        .collect(Collectors.toList());

      if (!derivedTypesHiding.isEmpty()) {
        reportIssue(typeToTypeTree.get(baseType),
          "Remove this type because it is unreachable as hidden by previous catch blocks.",
          derivedTypesHiding.stream().map(type -> new JavaFileScannerContext.Location("Already catch the exception", typeToTypeTree.get(type)))
          .collect(Collectors.toList()),
          null);
      }
    });
  }

