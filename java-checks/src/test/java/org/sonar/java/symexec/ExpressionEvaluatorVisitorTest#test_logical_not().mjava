  @Test
  public void test_logical_not() {
    Symbol.VariableSymbol ownerSymbol = mock(Symbol.VariableSymbol.class);
    when(ownerSymbol.isMethodSymbol()).thenReturn(true);
    Symbol.VariableSymbol identifierSymbol = mock(Symbol.VariableSymbol.class);
    when(identifierSymbol.isVariableSymbol()).thenReturn(true);
    when(identifierSymbol.owner()).thenReturn(ownerSymbol);
    IdentifierTreeImpl identifierTree = new IdentifierTreeImpl(TOKEN);
    identifierTree.setSymbol(identifierSymbol);
    InternalPrefixUnaryExpression logicalNotTree = new InternalPrefixUnaryExpression(Tree.Kind.LOGICAL_COMPLEMENT, TOKEN, identifierTree);

    ExecutionState state = new ExecutionState();

    evaluateUnaryOperator(state, logicalNotTree, identifierSymbol, FALSE, TRUE);

    state.setBooleanConstraint(identifierSymbol, FALSE);
    evaluateUnaryOperator(state, logicalNotTree, identifierSymbol, FALSE, null);

    state.setBooleanConstraint(identifierSymbol, TRUE);
    evaluateUnaryOperator(state, logicalNotTree, identifierSymbol, null, TRUE);

    state.setBooleanConstraint(identifierSymbol, UNKNOWN);
    evaluateUnaryOperator(state, logicalNotTree, identifierSymbol, FALSE, TRUE);
  }

