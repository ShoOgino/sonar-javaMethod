  @Test
  public void test_relational() {
    // tests registration of relations in the spawned true and false states.
    evaluateRelationalOperator("local1 > local2", SymbolicRelation.GREATER_THAN, SymbolicRelation.LESS_EQUAL);
    evaluateRelationalOperator("local1 >= local2", SymbolicRelation.GREATER_EQUAL, SymbolicRelation.LESS_THAN);
    evaluateRelationalOperator("local1 == local2", SymbolicRelation.EQUAL_TO, SymbolicRelation.NOT_EQUAL);
    evaluateRelationalOperator("local1 < local2", SymbolicRelation.LESS_THAN, SymbolicRelation.GREATER_EQUAL);
    evaluateRelationalOperator("local1 <= local2", SymbolicRelation.LESS_EQUAL, SymbolicRelation.GREATER_THAN);
    evaluateRelationalOperator("local1 != local2", SymbolicRelation.NOT_EQUAL, SymbolicRelation.EQUAL_TO);

    ExecutionState state = new ExecutionState();

    // no constraint must be registered if there is a field.
    validateEvaluationUnknownWithoutConstraints(state, analyze("field1 != field2"));
    validateEvaluationUnknownWithoutConstraints(state, analyze("field1 != local2"));
    validateEvaluationUnknownWithoutConstraints(state, analyze("local1 != field2"));

    ExpressionTree notEqualTree = analyze("local1 != local2");

    // under constraint local1 != local2 evaluation or local1 != local2 must return unconditionally true
    state.setRelation(local1Symbol(), SymbolicRelation.NOT_EQUAL, local2Symbol());
    validateEvaluationTrueWithoutConstraints(state, notEqualTree);

    // under constraint local1 == local2 evaluation or local1 == local2 must return unconditionally false
    state.setRelation(local1Symbol(), SymbolicRelation.EQUAL_TO, local2Symbol());
    validateEvaluationFalseWithoutConstraints(state, notEqualTree);

    // comparison must not fail if either or both operands are not identifiers.
    new ExpressionEvaluatorVisitor(state, parse("null == null"));
  }

