  private void handleExceptionalPaths(Symbol symbol) {
    TryStatement pop = enclosingTry.pop();
    TryStatement tryStatement;
    Block exceptionPredecessor = currentBlock;
    if (enclosedByCatch.peek()) {
      tryStatement = enclosingTry.peek();
    } else {
      tryStatement = pop;
    }
    enclosingTry.push(pop);
    if(pop != outerTry) {
      currentBlock = createBlock(currentBlock);
      currentBlock.exceptions.add(exitBlocks.peek());
      if(!enclosedByCatch.peek()) {
        exceptionPredecessor = currentBlock;
      }
    }
    if (symbol.isMethodSymbol()) {
      List<Type> thrownTypes = ((Symbol.MethodSymbol) symbol).thrownTypes();
      thrownTypes.forEach(thrownType -> {
        for (Type caughtType : tryStatement.catches.keySet()) {
          if (thrownType.isSubtypeOf(caughtType) || caughtType.isSubtypeOf(thrownType)) {
            currentBlock.exceptions.add(tryStatement.catches.get(caughtType));
          }
        }
      });
    }
    exceptionPredecessor.exceptions.addAll(tryStatement.runtimeCatches);
  }

