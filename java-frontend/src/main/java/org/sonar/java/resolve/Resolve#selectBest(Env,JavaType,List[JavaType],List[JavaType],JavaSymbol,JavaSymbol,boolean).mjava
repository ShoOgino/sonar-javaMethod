  /**
   * @param candidate    candidate
   * @param bestSoFar previously found best match
   */
  private JavaSymbol selectBest(Env env, JavaType site, List<JavaType> argTypes, List<JavaType> typeParams, JavaSymbol candidate, JavaSymbol bestSoFar, boolean autoboxing) {
    JavaSymbol.TypeJavaSymbol siteSymbol = site.symbol;
    // TODO get rid of null check
    if (candidate.kind >= JavaSymbol.ERRONEOUS || !isInheritedIn(candidate, siteSymbol) || candidate.type == null) {
      return bestSoFar;
    }
    JavaSymbol.MethodJavaSymbol methodJavaSymbol = (JavaSymbol.MethodJavaSymbol) candidate;
    boolean isVarArgs = methodJavaSymbol.isVarArgs();
    List<JavaType> formals = ((JavaType.MethodJavaType) candidate.type).argTypes;
    TypeSubstitution substitution = new TypeSubstitution();
    if (!formals.isEmpty()) {
      if (isParametrizedType(site)) {
        formals = applySubstitution(formals, ((JavaType.ParametrizedTypeJavaType) site).typeSubstitution);
      }
      if (!methodJavaSymbol.typeVariableTypes.isEmpty() && !typeParams.isEmpty()) {
        substitution = getSubstitutionFromTypeParams(methodJavaSymbol.typeVariableTypes, typeParams);
        if (substitution.size() == 0) {
          return bestSoFar;
        }
        formals = applySubstitution(formals, substitution);
      }
    }
    if (!isArgumentsAcceptable(argTypes, formals, isVarArgs, autoboxing)) {
      return bestSoFar;
    }
    // TODO ambiguity, errors, ...
    if (!isAccessible(env, siteSymbol, candidate)) {
      return new AccessErrorJavaSymbol(candidate, Symbols.unknownType);
    }
    JavaSymbol mostSpecific = selectMostSpecific(candidate, bestSoFar, substitution);
    if (mostSpecific.isKind(JavaSymbol.AMBIGUOUS)) {
      // same signature, we keep the first symbol found (overrides the other one).
      mostSpecific = bestSoFar;
    }
    return mostSpecific;
  }

