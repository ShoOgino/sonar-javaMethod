  /**
   * @param candidate    candidate
   * @param bestSoFar previously found best match
   */
  private Resolution selectBest(Env env, JavaType defSite, JavaType callSite, List<JavaType> argTypes, List<JavaType> typeParams,
                                JavaSymbol candidate, Resolution bestSoFar, boolean looseInvocation) {
    JavaSymbol.TypeJavaSymbol siteSymbol = callSite.symbol;
    // TODO get rid of null check
    if (candidate.kind >= JavaSymbol.ERRONEOUS || !isInheritedIn(candidate, siteSymbol) || candidate.type == null) {
      return bestSoFar;
    }
    JavaSymbol.MethodJavaSymbol methodJavaSymbol = (JavaSymbol.MethodJavaSymbol) candidate;
    if(!hasCompatibleArity(methodJavaSymbol.parameterTypes().size(), argTypes.size(), methodJavaSymbol.isVarArgs())) {
      return bestSoFar;
    }
    TypeSubstitution substitution = typeSubstitutionSolver.getTypeSubstitution(methodJavaSymbol, callSite, typeParams, argTypes);
    if (substitution == null) {
      return bestSoFar;
    }
    List<JavaType> formals = ((MethodJavaType) methodJavaSymbol.type).argTypes;
    formals = typeSubstitutionSolver.applySiteSubstitutionToFormalParameters(formals, callSite);
    if(defSite != callSite) {
      formals = typeSubstitutionSolver.applySiteSubstitutionToFormalParameters(formals, defSite);
    }
    formals = typeSubstitutionSolver.applySubstitutionToFormalParameters(formals, substitution);
    if (!isArgumentsAcceptable(argTypes, formals, methodJavaSymbol.isVarArgs(), looseInvocation)) {
      return bestSoFar;
    }
    // TODO ambiguity, errors, ...
    if (!isAccessible(env, siteSymbol, candidate)) {
      Resolution resolution = new Resolution(new AccessErrorJavaSymbol(candidate, Symbols.unknownType));
      resolution.type = Symbols.unknownType;
      return resolution;
    }
    JavaSymbol mostSpecific = selectMostSpecific(candidate, bestSoFar.symbol, argTypes, substitution, callSite);
    if (mostSpecific.isKind(JavaSymbol.AMBIGUOUS)) {
      // same signature, we keep the first symbol found (overrides the other one).
      return bestSoFar;
    }

    Resolution resolution = new Resolution(mostSpecific);
    JavaSymbol.MethodJavaSymbol mostSpecificMethod = (JavaSymbol.MethodJavaSymbol) mostSpecific;
    List<JavaType> thrownTypes = ((MethodJavaType) mostSpecific.type).thrown;
    JavaType returnType = ((MethodJavaType) mostSpecificMethod.type).resultType;
    if(applicableWithUncheckedConversion(mostSpecificMethod, defSite, typeParams) && !mostSpecificMethod.isConstructor()) {
      returnType = returnType.erasure();
      thrownTypes = erasure(thrownTypes);
    } else {
      returnType = typeSubstitutionSolver.getReturnType(returnType, defSite, callSite, substitution, mostSpecificMethod);
      thrownTypes = thrownTypes.stream()
        .map(t -> typeSubstitutionSolver.applySiteSubstitution(t, callSite))
        .map(t -> typeSubstitutionSolver.applySubstitution(t, substitution))
        .collect(Collectors.toList());
    }
    if (callSite.isArray() && candidate.name().equals("clone")) {
      returnType = callSite;
    }
    resolution.type = new MethodJavaType(formals, returnType, thrownTypes, defSite.symbol);
    return resolution;
  }

