  @Override
  public void visit(int version, int flags, String name, @Nullable String signature, @Nullable String superName, @Nullable String[] interfaces) {
    Preconditions.checkState(name.endsWith(classSymbol.name), "Name : '%s' should ends with %s", name, classSymbol.name);
    Preconditions.checkState(name.endsWith("package-info") || isNotSynthetic(flags), "%s is synthetic", name);
    className = name;
    if (signature != null) {
      SignatureReader signatureReader = new SignatureReader(signature);
      signatureReader.accept(new TypeParameterDeclaration(classSymbol));
      ReadGenericSignature readGenericSignature = new ReadGenericSignature();
      signatureReader.accept(readGenericSignature);
      ((ClassJavaType) classSymbol.type).interfaces = readGenericSignature.interfaces();
    } else {
      if (superName == null) {
        Preconditions.checkState("java/lang/Object".equals(className), "superName must be null only for java/lang/Object, but not for %s", className);
        // TODO(Godin): what about interfaces and annotations
      } else {
        ((ClassJavaType) classSymbol.type).supertype = getClassSymbol(superName).type;
      }
      ((ClassJavaType) classSymbol.type).interfaces = getCompletedClassSymbolsType(interfaces);

    }
    //if class has already access flags set (inner class) then do not reset those.
    //The important access flags are the one defined in the outer class.
    if ((classSymbol.flags & Flags.ACCESS_FLAGS) != 0) {
      classSymbol.flags |= Flags.filterAccessBytecodeFlags(flags & ~Flags.ACCESS_FLAGS);
    } else {
      classSymbol.flags |= Flags.filterAccessBytecodeFlags(flags);
    }
    classSymbol.members = new Scope(classSymbol);
  }

