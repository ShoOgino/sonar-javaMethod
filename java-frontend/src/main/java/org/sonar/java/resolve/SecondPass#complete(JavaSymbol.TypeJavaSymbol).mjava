  private void complete(JavaSymbol.TypeJavaSymbol symbol) {
    Resolve.Env env = semanticModel.getEnv(symbol);
    ClassJavaType type = (ClassJavaType) symbol.type;

    if (!symbol.isFlag(Flags.ANNOTATION)) {
      // JLS8 15.8.3 If this is a class or interface (default methods), enter symbol for "this"
      symbol.members.enter(new JavaSymbol.VariableJavaSymbol(Flags.FINAL, "this", symbol.type, symbol));
    }

    if ("".equals(symbol.name)) {
      // Anonymous Class Declaration
      // FIXME(Godin): This case avoids NPE which occurs because semanticModel has no associations for anonymous classes.
      type.interfaces = ImmutableList.of();
      return;
    }

    ClassTree tree = symbol.declaration;
    completeTypeParameters(tree.typeParameters(), env);

    //Interfaces
    ImmutableList.Builder<JavaType> interfaces = ImmutableList.builder();
    tree.superInterfaces().stream().map(interfaceTree -> resolveType(env, interfaceTree)).filter(Objects::nonNull).forEach(interfaces::add);

    if (tree.is(Tree.Kind.ANNOTATION_TYPE)) {
      // JLS8 9.6: The direct superinterface of every annotation type is java.lang.annotation.Annotation.
      // (Godin): Note that "extends" and "implements" clauses are forbidden by grammar for annotation types
      interfaces.add(symbols.annotationType);
    }

    if (tree.is(Tree.Kind.ENUM, Tree.Kind.INTERFACE) && symbol.owner.isKind(JavaSymbol.TYP)) {
      // JSL8 8.9: A nested enum type is implicitly static. It is permitted for the declaration of a nested 
      // enum type to redundantly specify the static modifier.
      symbol.flags |= Flags.STATIC;
    }

    type.interfaces = interfaces.build();

    populateSuperclass(symbol, env, type);

    if ((symbol.flags() & Flags.INTERFACE) == 0) {
      symbol.members.enter(new JavaSymbol.VariableJavaSymbol(Flags.FINAL, "super", type.supertype, symbol));
    } else {
      // JLS9 - 15.12.1 : Used in form 'TypeName.super.foo()', where 'TypeName' is an interface. To support invocation
      // of default methods from super-interfaces, 'TypeName' may also refer to a direct super-interface of the current
      // class or interface. The method being invoked ('foo()') has to be searched in that super-interface.
      symbol.members.enter(new JavaSymbol.VariableJavaSymbol(Flags.FINAL, "super", type, symbol));
      // Note: The above "super" symbol will always be qualified when referenced. e.g. A.super.hashCode()
      // because it's a compilation error to use unqualified "super" in default method. e.g. super.hashCode()
      // Note: interface/class can extend/implement multiple interfaces containing default methods with the same
      // signature. Mentioning the super-interfaces explicitly removes any ambiguity.
    }

    // Register default constructor
    if (tree.is(Tree.Kind.CLASS, Tree.Kind.ENUM) && symbol.lookupSymbols(CONSTRUCTOR_NAME).isEmpty()) {
      List<JavaType> argTypes = ImmutableList.of();
      if (!symbol.isStatic()) {
        // JLS8 - 8.8.1 & 8.8.9 : constructors of inner class have an implicit first arg of its directly enclosing class type
        JavaSymbol owner = symbol.owner();
        if (!owner.isPackageSymbol()) {
          argTypes = ImmutableList.of(owner.enclosingClass().type);
        }
      }
      JavaSymbol.MethodJavaSymbol defaultConstructor = new JavaSymbol.MethodJavaSymbol(symbol.flags & Flags.ACCESS_FLAGS, CONSTRUCTOR_NAME, symbol);
      MethodJavaType defaultConstructorType = new MethodJavaType(argTypes, null, ImmutableList.of(), symbol);
      defaultConstructor.setMethodType(defaultConstructorType);
      defaultConstructor.parameters = new Scope(defaultConstructor);
      symbol.members.enter(defaultConstructor);
    }
  }

