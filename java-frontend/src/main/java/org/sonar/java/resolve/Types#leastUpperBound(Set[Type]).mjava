  /**
   * Compute the "Least Upper Bound" ("lub", jls8 ยง4.10.4) of a list of type. The "lub" is a shared supertype that is more specific than any
   * other shared supertype (that is, no other shared supertype is a subtype of the least upper bound)
   *
   * Parameterized types are currently ignored, as the method is used only to handle Union Types Trees, themselves being used only
   * in catch trees. Note that Exceptions (any subclass of Throwable) cannot be generic (jls8 ยง8.1.2, ยง11.1.1: "compile-time error if a generic
   * class is a direct or indirect subclass of Throwable")
   *
   * @param types
   * @return the least upper bound of the types
   */
  public static Type leastUpperBound(Set<Type> types) {
    Preconditions.checkArgument(!types.isEmpty());
    Iterator<Type> iterator = types.iterator();
    Type first = iterator.next();
    //lub(U) = U
    if(types.size() == 1) {
      return first;
    }
    // Handle particular case while generics are not properly supported if a type is subtype of another then lub is that type: solve some cases of conditional operator.
    // FIXME: should be removed when dealing with generics is properly supported see SONARJAVA-1631
    if(types.size() == 2) {
      Type type2 = iterator.next();
      if(first.isSubtypeOf(type2)) {
        return type2;
      } else if(type2.isSubtypeOf(first)) {
        return first;
      }
    }


    List<Set<Type>> supertypes = supertypes(types);

    List<Type> candidates = intersection(supertypes);
    List<Type> minimalCandidates = minimalCandidates(candidates);
    if (minimalCandidates.isEmpty()) {
      return Symbols.unknownType;
    }

    return best(minimalCandidates);
  }

