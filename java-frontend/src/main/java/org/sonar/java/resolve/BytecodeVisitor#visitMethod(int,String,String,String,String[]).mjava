  @Override
  public MethodVisitor visitMethod(int flags, String name, String desc, @Nullable String signature, @Nullable String[] exceptions) {
    Objects.requireNonNull(name);
    Objects.requireNonNull(desc);
    if (isNotSynthetic(flags)) {
      if((flags & Opcodes.ACC_BRIDGE) != 0) {
        LOG.warn("bridge method {} not marked as synthetic in class {}", name, className);
        return null;
      }
      // TODO(Godin): according to JVMS 4.7.24 - parameter can be marked as synthetic
      MethodJavaType type = new MethodJavaType(
          convertAsmTypes(org.objectweb.asm.Type.getArgumentTypes(desc)),
          convertAsmType(org.objectweb.asm.Type.getReturnType(desc)),
          getCompletedClassSymbolsType(exceptions),
          classSymbol
      );
      int methodFlags = Flags.filterAccessBytecodeFlags(flags);
      if (classSymbol.isInterface() && Flags.isNotFlagged(methodFlags, Flags.ABSTRACT | Flags.PRIVATE | Flags.STATIC)) {
        // abstract, static nor private method of interface is a default method
        methodFlags |= Flags.DEFAULT;
      }
      final JavaSymbol.MethodJavaSymbol methodSymbol = new JavaSymbol.MethodJavaSymbol(methodFlags, name, type, classSymbol);
      methodSymbol.desc = desc;
      classSymbol.members.enter(methodSymbol);
      if (signature != null) {
        SignatureReader signatureReader = new SignatureReader(signature);
        signatureReader.accept(new TypeParameterDeclaration(methodSymbol));
        signatureReader.accept(new ReadMethodSignature(methodSymbol));
      }
      methodSymbol.parameters = new Scope(methodSymbol);
      for (int i = 0; i < type.argTypes.size(); i += 1) {
        methodSymbol.parameters.enter(new JavaSymbol.VariableJavaSymbol(0, "arg" + i, methodSymbol));
      }
      // checks for annotations on the method and its parameters
      return new BytecodeMethodVisitor(methodSymbol, this);
    }
    return null;
  }

