  public JavaSymbol.TypeJavaSymbol getClassSymbol(@Nullable JavaSymbol.TypeJavaSymbol classSymbolOwner, String bytecodeName, int flags) {
    String flatName = Convert.flatName(bytecodeName);
    JavaSymbol.TypeJavaSymbol symbol = classes.get(flatName);
    if (symbol == null) {
      String shortName = Convert.shortName(flatName);
      String packageName = Convert.packagePart(flatName);
      JavaSymbol.TypeJavaSymbol owner = classSymbolOwner;
      if(owner == null) {
        owner = getEnclosingClass(shortName, packageName);
      }
      int classFlags = Flags.filterAccessBytecodeFlags(flags);
      if (owner != null) {
        //handle innerClasses
        String name = Convert.innerClassName(Convert.shortName(owner.getFullyQualifiedName()), shortName);
        symbol = new JavaSymbol.TypeJavaSymbol(classFlags, name, owner, bytecodeName);
      } else {
        symbol = new JavaSymbol.TypeJavaSymbol(classFlags, shortName, enterPackage(packageName));
      }
      symbol.members = new Scope(symbol);
      symbol.typeParameters = new Scope(symbol);

      // (Godin): IOException will happen without this condition in case of missing class:
      if (classLoader.getResource(Convert.bytecodeName(flatName) + ".class") != null) {
        symbol.completer = this;
      } else {
        // Do not log missing annotation as they are not necessarily required in classpath for compiling
        if (!bytecodeName.endsWith("package-info") && isNotAnnotation(flags)) {
          classesNotFound.add(bytecodeName);
        }
        ((ClassJavaType) symbol.type).interfaces = Collections.emptyList();
        ((ClassJavaType) symbol.type).supertype = Symbols.unknownType;
      }

      classes.put(flatName, symbol);
    }
    return symbol;
  }

