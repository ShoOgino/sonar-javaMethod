  public JavaSymbol.TypeJavaSymbol getClassSymbol(@Nullable JavaSymbol.TypeJavaSymbol classSymbolOwner, String bytecodeName, int flags) {
    String flatName = Convert.flatName(bytecodeName);
    JavaSymbol.TypeJavaSymbol symbol = classes.get(flatName);
    if (symbol == null) {
      String shortName = Convert.shortName(flatName);
      String packageName = Convert.packagePart(flatName);
      JavaSymbol.TypeJavaSymbol owner = classSymbolOwner;
      if(owner == null) {
        String enclosingClassName = Convert.enclosingClassName(shortName);
        if(StringUtils.isNotEmpty(enclosingClassName)) {
          owner = getClassSymbol(Convert.fullName(packageName, enclosingClassName));
        }
      }
      if ( owner != null) {
        //handle innerClasses
        String name = Convert.innerClassName(Convert.shortName(owner.getFullyQualifiedName()), shortName);
        symbol = new JavaSymbol.TypeJavaSymbol(filterBytecodeFlags(flags), name, owner, bytecodeName);
      } else {
        symbol = new JavaSymbol.TypeJavaSymbol(filterBytecodeFlags(flags), shortName, enterPackage(packageName));
      }
      symbol.members = new Scope(symbol);
      symbol.typeParameters = new Scope(symbol);

      // (Godin): IOException will happen without this condition in case of missing class:
      if (getClassLoader().getResource(Convert.bytecodeName(flatName) + ".class") != null) {
        symbol.completer = this;
      } else {
        if (!bytecodeName.endsWith("package-info")) {
          LOG.warn("Class not found: " + bytecodeName);
        }
        ((ClassJavaType) symbol.type).interfaces = ImmutableList.of();
        ((ClassJavaType) symbol.type).supertype = Symbols.unknownType;
      }

      classes.put(flatName, symbol);
    }
    return symbol;
  }

