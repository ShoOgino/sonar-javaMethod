  private void complete(JavaSymbol.MethodJavaSymbol symbol) {
    MethodTree methodTree = symbol.declaration;
    Resolve.Env env = semanticModel.getEnv(symbol);
    completeTypeParameters(methodTree.typeParameters(), env);
    ImmutableList.Builder<JavaType> thrownTypes = ImmutableList.builder();
    for (TypeTree throwClause : methodTree.throwsClauses()) {
      JavaType thrownType = resolveType(env, throwClause);
      if (thrownType != null) {
        thrownTypes.add(thrownType);
      }
    }

    JavaType returnType = null;
    // no return type for constructor
    if (!"<init>".equals(symbol.name)) {
      returnType = resolveType(env, methodTree.returnType());
      if (returnType != null) {
        symbol.returnType = returnType.symbol;
      }
    }
    List<VariableTree> parametersTree = methodTree.parameters();
    List<JavaType> argTypes = Lists.newArrayList();
    List<JavaSymbol> scopeSymbols = symbol.parameters.scopeSymbols();
    for(int i = 0; i < parametersTree.size(); i += 1) {
      VariableTree variableTree = parametersTree.get(i);
      JavaSymbol param = scopeSymbols.get(i);
      if (variableTree.simpleName().name().equals(param.getName())) {
        param.complete();
        argTypes.add(param.getType());
      }
      if(((VariableTreeImpl)variableTree).isVararg()) {
        symbol.flags |= Flags.VARARGS;
      }
    }
    MethodJavaType methodType = new MethodJavaType(argTypes, returnType, thrownTypes.build(), (JavaSymbol.TypeJavaSymbol) symbol.owner);
    symbol.setMethodType(methodType);
  }

