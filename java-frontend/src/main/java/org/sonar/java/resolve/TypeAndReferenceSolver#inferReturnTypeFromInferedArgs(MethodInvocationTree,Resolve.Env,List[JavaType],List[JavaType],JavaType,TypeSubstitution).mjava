  private void inferReturnTypeFromInferedArgs(MethodInvocationTree tree, Resolve.Env methodEnv, List<JavaType> argTypes, List<JavaType> typeParamTypes,
                                              JavaType returnType, TypeSubstitution typeSubstitution) {
    List<JavaType> parameterTypes = getParameterTypes(tree.arguments());
    if(!parameterTypes.equals(argTypes)) {
      IdentifierTree identifier = null;
      Resolution resolution = null;
      Tree methodSelect = tree.methodSelect();
      if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree mset = (MemberSelectExpressionTree) methodSelect;
        JavaType type = getType(mset.expression());
        if(type.isTagged(JavaType.DEFERRED)) {
          throw new IllegalStateException("type of arg should not be defered anymore ??");
        }
        identifier = mset.identifier();
        resolution = resolve.findMethod(methodEnv, type, identifier.name(), parameterTypes, typeParamTypes);
      } else if (methodSelect.is(Tree.Kind.IDENTIFIER)) {
        identifier = (IdentifierTree) methodSelect;
        resolution = resolve.findMethod(methodEnv, identifier.name(), parameterTypes, typeParamTypes);
      }
      if(resolution != null && returnType != resolution.type() && resolution.symbol().isMethodSymbol()) {
        MethodJavaType methodType = (MethodJavaType) resolution.type();
        if(!methodType.resultType.isTagged(JavaType.DEFERRED)) {
          registerType(tree, resolve.applySubstitution(methodType.resultType, typeSubstitution));
          // update type associated to identifier as it may have been inferred deeper when re-resolving method with new parameter types
          registerType(identifier, methodType);
        }
      }
    } else {
      registerType(tree, resolve.applySubstitution(returnType, typeSubstitution));
    }
  }

