  public JavaSymbol resolveAs(Tree tree, int kind, Resolve.Env resolveEnv, boolean associateReference) {
    if (tree.is(Tree.Kind.IDENTIFIER, Tree.Kind.MEMBER_SELECT)) {
      JavaSymbol resolvedSymbol;
      IdentifierTree identifierTree;
      if (tree.is(Tree.Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree mse = (MemberSelectExpressionTree) tree;
        if (JavaKeyword.CLASS.getValue().equals(mse.identifier().name())) {
          // resolve type of expression xxx.class
          return resolveClassType(tree, resolveEnv, mse);
        }
        identifierTree = mse.identifier();

        List<AnnotationTree> identifierAnnotations = identifierTree.annotations();
        scan(identifierAnnotations);
        completeMetadata((JavaSymbol) identifierTree.symbol(), identifierAnnotations);

        Resolve.Resolution res = getSymbolOfMemberSelectExpression(mse, kind, resolveEnv);
        resolvedSymbol = res.symbol();
        JavaType resolvedType = resolve.resolveTypeSubstitution(res.type(), getType(mse.expression()));
        registerType(identifierTree, resolvedType);
        registerType(tree, resolvedType);
      } else {
        identifierTree = (IdentifierTree) tree;
        Resolve.Resolution resolution = resolve.findIdent(resolveEnv, identifierTree.name(), kind);
        resolvedSymbol = resolution.symbol();

        // Resolve annotations which can be present (for instance) when declaring types: "List<@MyAnnotation MyClass>"
        // but do not associate it with the symbol of the identifier (that would be a non-sense to associate '@MyAnnotation'
        // with the 'MyClass' symbol type)
        scan(identifierTree.annotations());

        JavaType type = resolution.type();
        if(kind == JavaSymbol.TYP && type.isParameterized()) {
          type = type.erasure();
        }
        registerType(tree, type);
      }
      if(associateReference) {
        associateReference(identifierTree, resolvedSymbol);
      }
      return resolvedSymbol;
    }
    tree.accept(this);
    JavaType type = getType(tree);
    if (tree.is(Tree.Kind.INFERED_TYPE, Tree.Kind.VAR_TYPE)) {
      type = symbols.deferedType((AbstractTypedTree) tree);
      registerType(tree, type);
    }
    if (type == null) {
      throw new IllegalStateException("Type not resolved " + tree);
    }
    return type.symbol;
  }

