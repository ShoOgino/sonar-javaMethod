  private boolean isAcceptableType(JavaType arg, JavaType formal, boolean autoboxing) {
    if(arg.isTagged(JavaType.DEFERRED)) {
      List<JavaType> samMethodArgs = findSamMethodArgs(formal);
      if(((DeferredType) arg).tree().is(Tree.Kind.LAMBDA_EXPRESSION)) {
        return ((LambdaExpressionTree) ((DeferredType) arg).tree()).parameters().size() == samMethodArgs.size();
      }
      // we accept all deferred type as we will resolve this later.
      return true;
    }
    if(formal.isTagged(JavaType.TYPEVAR) && !arg.isTagged(JavaType.TYPEVAR)) {
      return subtypeOfTypeVar(arg, (TypeVariableJavaType) formal);
    }
    if (formal.isArray() && arg.isArray()) {
      return isAcceptableType(((ArrayJavaType) arg).elementType(), ((ArrayJavaType) formal).elementType(), autoboxing);
    }

    if (arg.isParameterized() || formal.isParameterized() || isWilcardType(arg) || isWilcardType(formal)) {
      return callWithRawType(arg, formal) || types.isSubtype(arg, formal) || isAcceptableByAutoboxing(arg, formal.erasure());
    }
    // fall back to behavior based on erasure
    return types.isSubtype(arg.erasure(), formal.erasure()) || (autoboxing && isAcceptableByAutoboxing(arg, formal.erasure()));
  }

