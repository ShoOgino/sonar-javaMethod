  /**
   * @return true, if signature of m1 is more specific than signature of m2
   */
  private boolean isSignatureMoreSpecific(JavaSymbol m1, JavaSymbol m2, List<JavaType> argTypes, TypeSubstitution substitution) {
    List<JavaType> m1ArgTypes = ((MethodJavaType) m1.type).argTypes;
    List<JavaType> m2ArgTypes = ((MethodJavaType) m2.type).argTypes;
    JavaSymbol.MethodJavaSymbol methodJavaSymbol = (JavaSymbol.MethodJavaSymbol) m1;
    boolean m1VarArity = methodJavaSymbol.isVarArgs();
    boolean m2VarArity = ((JavaSymbol.MethodJavaSymbol) m2).isVarArgs();
    if (m1VarArity != m2VarArity) {
      // last arg is an array
      boolean lastArgIsArray = !argTypes.isEmpty() && argTypes.get(argTypes.size() -1).isArray() && (argTypes.size() == m2ArgTypes.size() || argTypes.size() == m1ArgTypes.size());
      // general case : prefer strict arity invocation over varArity, so if m2 is variadic, m1 is most specific, but not if last arg of invocation is an array
      return lastArgIsArray ^ m2VarArity;
    }
    if (m1VarArity) {
      m1ArgTypes = expandVarArgsToFitSize(m1ArgTypes, m2ArgTypes.size());
    }
    if(!hasCompatibleArity(m1ArgTypes.size(), m2ArgTypes.size(), m2VarArity)) {
      return false;
    }
    m1ArgTypes = typeSubstitutionSolver.applySubstitutionToFormalParameters(m1ArgTypes, substitution);
    return isArgumentsAcceptable(m1ArgTypes, m2ArgTypes, m2VarArity, false);
  }

