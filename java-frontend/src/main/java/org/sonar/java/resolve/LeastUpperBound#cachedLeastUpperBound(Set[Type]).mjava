  private Type cachedLeastUpperBound(Set<Type> types) {
    Preconditions.checkArgument(!types.isEmpty());

    Iterator<Type> iterator = types.iterator();
    Type first = iterator.next();
    // lub(U) = U
    if (types.size() == 1) {
      return first;
    }

    List<Set<Type>> supertypes = supertypes(types);
    List<Set<Type>> erasedSupertypes = erased(supertypes);

    List<Type> erasedCandidates = intersection(erasedSupertypes);
    List<Type> minimalErasedCandidates = minimalCandidates(erasedCandidates);
    if (minimalErasedCandidates.isEmpty()) {
      return Symbols.unknownType;
    }

    Multimap<Type, Type> relevantParameterizations = relevantParameterizations(minimalErasedCandidates, supertypes);

    Type erasedBest = best(minimalErasedCandidates);

    Collection<Type> erasedTypeParameterizations = relevantParameterizations.get(erasedBest);
    if (erasedTypeParameterizations != null && !erasedTypeParameterizations.contains(erasedBest)) {
      Set<Type> searchedTypes = new HashSet<>(types);
      // if we already encountered these types in LUB calculation,
      // we interrupt calculation and use the erasure of the parameterized type instead
      if (!lubCache.contains(searchedTypes)) {
        lubCache.add(searchedTypes);
        return leastContainingParameterization(new ArrayList<>(erasedTypeParameterizations));
      }
    }
    return erasedBest;

  }

