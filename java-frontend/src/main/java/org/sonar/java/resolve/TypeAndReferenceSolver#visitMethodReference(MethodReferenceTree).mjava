  @Override
  public void visitMethodReference(MethodReferenceTree methodReferenceTree) {
    MethodReferenceTreeImpl methodRefTree = (MethodReferenceTreeImpl) methodReferenceTree;
    if(methodRefTree.isTypeSet()) {
      JavaType methodRefType = (JavaType) methodRefTree.symbolType();
      resolve.getSamMethod(methodRefType)
        .map(samMethod -> (JavaType) samMethod.returnType().type())
        .ifPresent(samReturnType -> {
          JavaSymbol methodSymbol = (JavaSymbol) methodRefTree.method().symbol();
          if (!"<init>".equals(methodSymbol.name) && methodSymbol.isMethodSymbol()) {
            JavaType capturedReturnType = resolve.resolveTypeSubstitution(samReturnType, methodRefType);
            JavaType refinedReturnType = ((MethodJavaType) methodRefTree.method().symbolType()).resultType();
            refineType(methodRefTree, methodRefType, capturedReturnType, refinedReturnType);
          } else {
            handleNewArray(methodReferenceTree, methodRefType, samReturnType);
          }
        });
    } else {
      // TODO : SONARJAVA-1663 : consider type arguments for method resolution and substitution
      scan(methodReferenceTree.typeArguments());
      resolveAs(methodReferenceTree.expression(), JavaSymbol.VAR | JavaSymbol.TYP);
      registerType(methodRefTree, symbols.deferedType(methodRefTree));
    }
  }

