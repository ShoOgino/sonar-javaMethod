  @Override
  public void visitMethodReference(MethodReferenceTree methodReferenceTree) {
    MethodReferenceTreeImpl methodRefTree = (MethodReferenceTreeImpl) methodReferenceTree;
    if(methodRefTree.isTypeSet()) {
      resolveAs(methodReferenceTree.expression(), JavaSymbol.VAR | JavaSymbol.TYP);
      scan(methodReferenceTree.typeArguments());
      // TODO : SONARJAVA-1663 : consider type arguments for method resolution and substitution
      Resolve.Env methodEnv = semanticModel.getEnv(methodReferenceTree);
      List<JavaType> samMethodArgs = resolve.findSamMethodArgs(methodReferenceTree.symbolType());
      Resolve.Resolution resolution;
      if("new".equals(methodReferenceTree.method().name())) {
        resolution = resolve.findMethod(methodEnv, getType(methodReferenceTree.expression()), "<init>", samMethodArgs);
        associateReference(methodReferenceTree.method(), resolution.symbol());
        return;
      }
      resolveMethodSymbol(methodReferenceTree.method(), methodEnv, samMethodArgs, ImmutableList.<JavaType>of());
      JavaType methodRefType = (JavaType) methodRefTree.symbolType();
      if (methodRefType.isUnknown() || methodRefType.isTagged(JavaType.DEFERRED)) {
        return;
      }
      JavaSymbol.MethodJavaSymbol samMethod = getSamMethod(methodRefType);
      if(samMethod == null) {
        return;
      }
      JavaType samReturnType = (JavaType) samMethod.returnType().type();
      JavaType methodType = (JavaType) methodRefTree.method().symbolType();
      if(methodType.isTagged(JavaType.METHOD)) {
        JavaType refinedReturnType = ((MethodJavaType) methodType).resultType;
        JavaType capturedReturnType = resolve.resolveTypeSubstitution(samReturnType, methodRefType);
        refineType(methodRefTree, methodRefType, capturedReturnType, refinedReturnType);
      }
    } else {
      registerType(methodRefTree, symbols.deferedType(methodRefTree));
    }
  }

