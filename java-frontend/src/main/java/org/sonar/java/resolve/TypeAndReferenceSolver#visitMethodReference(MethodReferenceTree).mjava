  @Override
  public void visitMethodReference(MethodReferenceTree methodReferenceTree) {
    MethodReferenceTreeImpl methodRefTree = (MethodReferenceTreeImpl) methodReferenceTree;
    if (methodRefTree.isTypeSet() && methodReferenceTree.typeArguments() == null) {
      JavaType methodRefType = (JavaType) methodRefTree.symbolType();
      resolve.getSamMethod(methodRefType).ifPresent(samMethod -> {
        JavaType samReturnType = (JavaType) samMethod.returnType().type();
        List<JavaType> samMethodArgs = resolve.findSamMethodArgs(methodRefType);
        Resolution resolution = resolve.findMethodReference(semanticModel.getEnv(methodReferenceTree), samMethodArgs, methodRefTree);
        JavaSymbol methodSymbol = resolution.symbol();
        if (methodSymbol.isMethodSymbol()) {
          IdentifierTree methodIdentifier = methodRefTree.method();
          addMethodRefReference(methodIdentifier, methodSymbol);
          setMethodRefType(methodRefTree, methodRefType, resolution.type());

          JavaType capturedReturnType = resolve.resolveTypeSubstitution(samReturnType, methodRefType);
          JavaType refinedReturnType = ((MethodJavaType) methodIdentifier.symbolType()).resultType();
          if ("<init>".equals(methodSymbol.name)) {
            refinedReturnType = refinedTypeForConstructor(capturedReturnType, refinedReturnType);
          }
          refineType(methodRefTree, methodRefType, capturedReturnType, refinedReturnType);
        } else {
          handleNewArray(methodRefTree, methodRefType, samReturnType);
        }
      });
    } else {
      // TODO : SONARJAVA-1663 : consider type arguments for method resolution and substitution
      scan(methodReferenceTree.typeArguments());
      resolveAs(methodReferenceTree.expression(), JavaSymbol.VAR | JavaSymbol.TYP);
      registerType(methodRefTree, symbols.deferedType(methodRefTree));
    }
  }

