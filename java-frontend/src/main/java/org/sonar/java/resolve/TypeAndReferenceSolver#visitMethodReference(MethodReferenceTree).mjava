  @Override
  public void visitMethodReference(MethodReferenceTree methodReferenceTree) {
    MethodReferenceTreeImpl methodRefTree = (MethodReferenceTreeImpl) methodReferenceTree;
    if(methodRefTree.isTypeSet()) {
      JavaType methodRefType = (JavaType) methodRefTree.symbolType();
      JavaSymbol.MethodJavaSymbol samMethod = resolve.getSamMethod(methodRefType);
      if (samMethod == null) {
        return;
      }
      JavaSymbol methodSymbol = (JavaSymbol) methodRefTree.method().symbol();
      if (!"<init>".equals(methodSymbol.name) && methodSymbol.isMethodSymbol()) {
        JavaType samReturnType = (JavaType) samMethod.returnType().type();
        JavaType capturedReturnType = resolve.resolveTypeSubstitution(samReturnType, methodRefType);
        JavaType refinedReturnType = (JavaType) ((Symbol.MethodSymbol) methodSymbol).returnType().type();
        refineType(methodRefTree, methodRefType, capturedReturnType, refinedReturnType);
      }
    } else {
      // TODO : SONARJAVA-1663 : consider type arguments for method resolution and substitution
      scan(methodReferenceTree.typeArguments());
      resolveAs(methodReferenceTree.expression(), JavaSymbol.VAR | JavaSymbol.TYP);
      registerType(methodRefTree, symbols.deferedType(methodRefTree));
    }
  }

