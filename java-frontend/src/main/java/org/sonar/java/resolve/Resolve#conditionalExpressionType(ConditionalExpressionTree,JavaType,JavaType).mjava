  public JavaType conditionalExpressionType(ConditionalExpressionTree tree, JavaType trueType, JavaType falseType) {
    if (trueType.isTagged(JavaType.DEFERRED) || falseType.isTagged(JavaType.DEFERRED)) {
      return symbols.deferedType((ConditionalExpressionTreeImpl) tree);
    }
    if (trueType == falseType) {
      return trueType;
    }
    if (trueType.isTagged(JavaType.BOT)) {
      return falseType.isPrimitive() ? falseType.primitiveWrapperType() : falseType;
    }
    if (falseType.isTagged(JavaType.BOT)) {
      return trueType.isPrimitive() ? trueType.primitiveWrapperType() : trueType;
    }
    JavaType secondOperand = getPrimitive(trueType);
    JavaType thirdOperand = getPrimitive(falseType);
    if (secondOperand != null && thirdOperand != null && isNumericalConditionalExpression(secondOperand, thirdOperand)) {
      // If operand is a constant int that can fits a narrow type it should be narrowed. We always narrow to approximate things properly for
      // method resolution.
      if ((secondOperand.tag < thirdOperand.tag || secondOperand.isTagged(JavaType.INT)) && !thirdOperand.isTagged(JavaType.INT)) {
        return thirdOperand;
      } else {
        return secondOperand;
      }
    }
    return (JavaType) leastUpperBound(Sets.<Type>newHashSet(trueType, falseType));
  }

