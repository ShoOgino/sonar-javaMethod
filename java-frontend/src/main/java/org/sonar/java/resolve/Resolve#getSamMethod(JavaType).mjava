  public Optional<JavaSymbol.MethodJavaSymbol> getSamMethod(JavaType lambdaType) {
    List<JavaSymbol.MethodJavaSymbol> methodSymbols = abstractMethodsOfType(lambdaType);
    if (methodSymbols.size() > 1) {
      return Optional.empty();
    }
    if (methodSymbols.size() == 1) {
      JavaSymbol.MethodJavaSymbol override = methodSymbols.get(0).overriddenSymbol();
      Optional<JavaSymbol.MethodJavaSymbol> otherAbstractMethod = lambdaType.symbol.superTypes()
        .stream()
        .filter(t -> t.symbol().isInterface())
        .flatMap(t -> abstractMethodsOfType(t).stream())
        .filter(m -> override == null || !override.equals(m))
        .findFirst();
      if (otherAbstractMethod.isPresent()) {
        return Optional.empty();
      } else {
        return Optional.of(methodSymbols.get(0));
      }
    } else {
      // FIXME if list of supertypes define multiple abstract methods we might end up with a wrong samMethod from a non-functional interface
      return lambdaType.symbol.superTypes()
        .stream()
        .flatMap(t -> abstractMethodsOfType(t).stream())
        .findFirst();
    }
  }

