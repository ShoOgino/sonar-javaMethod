  @VisibleForTesting
  static Type best(List<Type> minimalCandidates) {
    Collections.sort(minimalCandidates, new Comparator<Type>() {
      // Sort minimal candidates by name with classes before interfaces, to guarantee always the same type is returned when approximated.
      @Override
      public int compare(Type type, Type t1) {
        Symbol.TypeSymbol typeSymbol = type.symbol();
        Symbol.TypeSymbol t1Symbol = t1.symbol();
        if (typeSymbol.isInterface() && t1Symbol.isInterface()) {
          return type.name().compareTo(t1.name());
        } else if (typeSymbol.isInterface()) {
          return 1;
        } else if (t1Symbol.isInterface()) {
          return -1;
        }
        return type.name().compareTo(t1.name());
      }
    });
    return minimalCandidates.get(0);
  }

