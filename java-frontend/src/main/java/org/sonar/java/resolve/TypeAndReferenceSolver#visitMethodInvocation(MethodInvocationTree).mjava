  @Override
  public void visitMethodInvocation(MethodInvocationTree tree) {
    MethodInvocationTreeImpl mit = (MethodInvocationTreeImpl) tree;
    if(mit.isTypeSet()) {
      // nothing special to deduce once we have set type of expression
      return;
    }
    Tree methodSelect = tree.methodSelect();
    Resolve.Env methodEnv = semanticModel.getEnv(tree);
    scan(tree.arguments());
    scan(tree.typeArguments());
    List<JavaType> argTypes = getParameterTypes(tree.arguments());
    List<JavaType> typeParamTypes = Lists.newArrayList();
    if(tree.typeArguments() != null ) {
      typeParamTypes = getParameterTypes(tree.typeArguments());
    }
    Resolve.Resolution resolution = resolveMethodSymbol(methodSelect, methodEnv, argTypes, typeParamTypes);
    JavaSymbol symbol = resolution.symbol();
    mit.setSymbol(symbol);
    JavaType returnType = resolution.type();
    if(resolution.symbol().isMethodSymbol()) {
      MethodJavaType methodType = (MethodJavaType) resolution.type();
      returnType = methodType.resultType;
    }
    if(returnType != null && returnType.isTagged(JavaType.DEFERRED)) {
      ((DeferredType) returnType).setTree(mit);
    }
    registerType(tree, returnType);
    inferArgumentTypes(argTypes, resolution);
  }

