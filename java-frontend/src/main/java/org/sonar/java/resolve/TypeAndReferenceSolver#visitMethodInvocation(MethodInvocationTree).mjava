  @Override
  public void visitMethodInvocation(MethodInvocationTree tree) {
    MethodInvocationTreeImpl mit = (MethodInvocationTreeImpl) tree;
    Resolve.Env methodEnv = semanticModel.getEnv(tree);
    if(mit.isTypeSet() && mit.symbol().isMethodSymbol()) {
      TypeSubstitution typeSubstitution = inferedSubstitution(mit);
      List<JavaType> argTypes = getParameterTypes(tree.arguments());
      JavaSymbol.MethodJavaSymbol methodSymbol = (JavaSymbol.MethodJavaSymbol) mit.symbol();
      List<JavaType> formals = methodSymbol.parameterTypes().stream().map(t -> (JavaType) t).collect(Collectors.toList());
      List<JavaType> inferedArgTypes = resolve.resolveTypeSubstitution(formals, typeSubstitution);
      int size = inferedArgTypes.size();
      IntStream.range(0, argTypes.size()).forEach(
        i -> {
          JavaType arg = argTypes.get(i);
          Type formal = inferedArgTypes.get(Math.min(i, size - 1));
          if (formal != arg) {
            AbstractTypedTree argTree = (AbstractTypedTree) mit.arguments().get(i);
            argTree.setInferedType(formal);
            argTree.accept(this);
          }
        }
      );
      List<JavaType> typeParamTypes = getParameterTypes(tree.typeArguments());
      JavaType resultType = ((MethodJavaType) mit.symbol().type()).resultType;
      // if result type is a type var defined by the method we are solving, use the target type.
      if(resultType.symbol.owner == mit.symbol()) {
        resultType = (JavaType) mit.symbolType();
      }
      inferReturnTypeFromInferedArgs(tree, methodEnv, argTypes, typeParamTypes, resultType, typeSubstitution);
      return;
    }
    scan(tree.arguments());
    scan(tree.typeArguments());
    List<JavaType> argTypes = getParameterTypes(tree.arguments());
    List<JavaType> typeParamTypes = getParameterTypes(tree.typeArguments());
    Resolve.Resolution resolution = resolveMethodSymbol(tree.methodSelect(), methodEnv, argTypes, typeParamTypes);
    JavaSymbol symbol;
    JavaType returnType;
    if(resolution == null) {
      returnType = symbols.deferedType(mit);
      symbol = Symbols.unknownSymbol;
    } else {
      symbol = resolution.symbol();
      returnType = resolution.type();
      if(symbol.isMethodSymbol()) {
        MethodJavaType methodType = (MethodJavaType) resolution.type();
        returnType = methodType.resultType;
      }
    }
    mit.setSymbol(symbol);
    if(returnType != null && returnType.isTagged(JavaType.DEFERRED)) {
      ((DeferredType) returnType).setTree(mit);
    }
    registerType(tree, returnType);
    if(resolution != null) {
      inferArgumentTypes(argTypes, resolution);
      inferReturnTypeFromInferedArgs(tree, methodEnv, argTypes, typeParamTypes, returnType, new TypeSubstitution());
    }
  }

