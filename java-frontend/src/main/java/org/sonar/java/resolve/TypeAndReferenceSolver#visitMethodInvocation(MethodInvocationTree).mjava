  @Override
  public void visitMethodInvocation(MethodInvocationTree tree) {
    MethodInvocationTreeImpl mit = (MethodInvocationTreeImpl) tree;
    if(mit.isTypeSet() && mit.symbol().isMethodSymbol()) {
      TypeSubstitution typeSubstitution = inferedSubstitution(mit);
      List<JavaType> argTypes = getParameterTypes(tree.arguments());
      JavaSymbol.MethodJavaSymbol methodSymbol = (JavaSymbol.MethodJavaSymbol) mit.symbol();
      List<JavaType> inferedArgTypes = resolve.resolveTypeSubstitution(methodSymbol.parameterTypes().stream().map(t -> (JavaType) t).collect(Collectors.toList()), typeSubstitution);
      for (int i = 0; i < argTypes.size(); i++) {
        JavaType arg = argTypes.get(i);
        int size = inferedArgTypes.size();
        Type formal = inferedArgTypes.get((i < size) ? i : (size - 1));
        if (formal != arg) {
          AbstractTypedTree argTree = (AbstractTypedTree) mit.arguments().get(i);
          argTree.setInferedType(formal);
          argTree.accept(this);
        }
      }
      return;
    }
    Tree methodSelect = tree.methodSelect();
    Resolve.Env methodEnv = semanticModel.getEnv(tree);
    scan(tree.arguments());
    scan(tree.typeArguments());
    List<JavaType> argTypes = getParameterTypes(tree.arguments());
    List<JavaType> typeParamTypes = Lists.newArrayList();
    if(tree.typeArguments() != null ) {
      typeParamTypes = getParameterTypes(tree.typeArguments());
    }
    Resolve.Resolution resolution = resolveMethodSymbol(methodSelect, methodEnv, argTypes, typeParamTypes);
    JavaSymbol symbol = resolution.symbol();
    mit.setSymbol(symbol);
    JavaType returnType = resolution.type();
    if(resolution.symbol().isMethodSymbol()) {
      MethodJavaType methodType = (MethodJavaType) resolution.type();
      returnType = methodType.resultType;
    }
    if(returnType != null && returnType.isTagged(JavaType.DEFERRED)) {
      ((DeferredType) returnType).setTree(mit);
    }
    registerType(tree, returnType);
    inferArgumentTypes(argTypes, resolution);
  }

