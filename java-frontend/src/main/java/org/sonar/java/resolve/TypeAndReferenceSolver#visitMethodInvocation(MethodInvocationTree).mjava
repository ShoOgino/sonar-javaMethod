  @Override
  public void visitMethodInvocation(MethodInvocationTree tree) {
    MethodInvocationTreeImpl mit = (MethodInvocationTreeImpl) tree;
    if(mit.isTypeSet() && mit.symbol().isMethodSymbol()) {
      TypeSubstitution typeSubstitution = inferedSubstitution(mit);
      List<JavaType> argTypes = getParameterTypes(tree.arguments());
      JavaSymbol.MethodJavaSymbol methodSymbol = (JavaSymbol.MethodJavaSymbol) mit.symbol();
      List<JavaType> formals = methodSymbol.parameterTypes().stream().map(t -> (JavaType) t).collect(Collectors.toList());
      List<JavaType> inferedArgTypes = resolve.resolveTypeSubstitution(formals, typeSubstitution);
      int size = inferedArgTypes.size();
      IntStream.range(0, argTypes.size()).forEach(
        i -> {
          JavaType arg = argTypes.get(i);
          Type formal = inferedArgTypes.get(Math.min(i, size - 1));
          if (formal != arg) {
            AbstractTypedTree argTree = (AbstractTypedTree) mit.arguments().get(i);
            argTree.setInferedType(formal);
            argTree.accept(this);
          }
        }
      );
      return;
    }
    Tree methodSelect = tree.methodSelect();
    Resolve.Env methodEnv = semanticModel.getEnv(tree);
    scan(tree.arguments());
    scan(tree.typeArguments());
    List<JavaType> argTypes = getParameterTypes(tree.arguments());
    List<JavaType> typeParamTypes = getParameterTypes(tree.typeArguments());
    Resolve.Resolution resolution = resolveMethodSymbol(methodSelect, methodEnv, argTypes, typeParamTypes);
    JavaSymbol symbol;
    JavaType returnType;
    if(resolution == null) {
      returnType = symbols.deferedType(mit);
      symbol = Symbols.unknownSymbol;
    } else {
      symbol = resolution.symbol();
      returnType = resolution.type();
      if(symbol.isMethodSymbol()) {
        MethodJavaType methodType = (MethodJavaType) resolution.type();
        returnType = methodType.resultType;
      }
    }
    mit.setSymbol(symbol);
    if(returnType != null && returnType.isTagged(JavaType.DEFERRED)) {
      ((DeferredType) returnType).setTree(mit);
    }
    registerType(tree, returnType);
    if(resolution != null) {
      inferArgumentTypes(argTypes, resolution);
      List<JavaType> parameterTypes = getParameterTypes(tree.arguments());
      if(!parameterTypes.equals(argTypes)) {
        IdentifierTree identifier;
        if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
          MemberSelectExpressionTree mset = (MemberSelectExpressionTree) methodSelect;
          JavaType type = getType(mset.expression());
          if(type.isTagged(JavaType.DEFERRED)) {
            throw new IllegalStateException("type of arg should not be defered anymore ??");
          }
          identifier = mset.identifier();
          resolution = resolve.findMethod(methodEnv, type, identifier.name(), parameterTypes, typeParamTypes);
        } else if (methodSelect.is(Tree.Kind.IDENTIFIER)) {
          identifier = (IdentifierTree) methodSelect;
          resolution = resolve.findMethod(methodEnv, identifier.name(), parameterTypes, typeParamTypes);
        }
        if(resolution != null && returnType != resolution.type() && resolution.symbol().isMethodSymbol()) {
          MethodJavaType methodType = (MethodJavaType) resolution.type();
          if(!methodType.resultType.isTagged(JavaType.DEFERRED)) {
            registerType(tree, methodType.resultType);
          }
        }
      }
    }
  }

