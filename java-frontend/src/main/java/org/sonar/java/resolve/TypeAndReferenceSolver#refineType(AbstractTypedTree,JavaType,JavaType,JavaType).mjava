  private void refineType(AbstractTypedTree expression, JavaType expressionType, JavaType capturedReturnType, JavaType refinedReturnType) {
    if (refinedReturnType != capturedReturnType) {
      // found a lambda return type different from the one infered : update infered type
      if (expressionType.isTagged(JavaType.PARAMETERIZED)) {
        ParametrizedTypeJavaType functionType = (ParametrizedTypeJavaType) resolve.functionType((ParametrizedTypeJavaType) expressionType);
        TypeSubstitution typeSubstitution = ((ParametrizedTypeJavaType) expressionType).typeSubstitution;
        typeSubstitution.substitutionEntries().stream()
          .filter(e -> e.getValue() == capturedReturnType)
          .map(Map.Entry::getKey)
          .findFirst()
          .ifPresent(t -> {
            if(refinedReturnType instanceof DeferredType) {
              setInferedType(functionType.typeSubstitution.substitutedType(t), (DeferredType) refinedReturnType);
            } else  {
              TypeSubstitution refinedSubstitution = new TypeSubstitution(typeSubstitution).add(t, refinedReturnType);
              JavaType refinedType = parametrizedTypeCache.getParametrizedTypeType(expressionType.symbol, refinedSubstitution);
              expression.setType(refinedType);
            }
          });
      } else {
        expression.setType(refinedReturnType);
      }
    }
  }

