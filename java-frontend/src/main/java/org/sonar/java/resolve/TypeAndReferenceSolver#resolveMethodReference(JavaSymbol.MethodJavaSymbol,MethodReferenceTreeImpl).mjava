  private void resolveMethodReference(JavaSymbol.MethodJavaSymbol samMethod, MethodReferenceTreeImpl methodRefTree) {
    JavaType methodRefType = (JavaType) methodRefTree.symbolType();
    JavaType samReturnType = (JavaType) samMethod.returnType().type();
    List<JavaType> samMethodArgs = resolve.findSamMethodArgs(methodRefType);
    if (JavaKeyword.NEW.getValue().equals(methodRefTree.method().name())) {
      Type constructorType = ((AbstractTypedTree) methodRefTree.expression()).symbolType();
      samMethodArgs = addImplicitOuterClassParameter(samMethodArgs, (JavaSymbol.TypeJavaSymbol) constructorType.symbol());
    }
    Resolution resolution = resolve.findMethodReference(semanticModel.getEnv(methodRefTree), samMethodArgs, methodRefTree);
    JavaSymbol methodSymbol = resolution.symbol();
    if (methodSymbol.isMethodSymbol()) {
      IdentifierTree methodIdentifier = methodRefTree.method();
      addMethodRefReference(methodIdentifier, methodSymbol);
      setMethodRefType(methodRefTree, methodRefType, resolution.type());

      JavaType capturedReturnType = resolve.resolveTypeSubstitution(samReturnType, methodRefType);
      JavaType refinedReturnType = ((MethodJavaType) methodIdentifier.symbolType()).resultType();
      if ("<init>".equals(methodSymbol.name)) {
        refinedReturnType = refinedTypeForConstructor(capturedReturnType, refinedReturnType);
      }
      if (refinedReturnType instanceof DeferredType) {
        ((DeferredType) refinedReturnType).setTree((AbstractTypedTree) methodRefTree.method());
      }
      refineType(methodRefTree, methodRefType, capturedReturnType, refinedReturnType);
    } else {
      handleNewArray(methodRefTree, methodRefType, samReturnType);
    }
  }

