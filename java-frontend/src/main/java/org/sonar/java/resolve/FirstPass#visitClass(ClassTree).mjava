  @Override
  public void visitClass(ClassTree tree) {
    int flag = 0;
    boolean anonymousClass = tree.simpleName() == null;
    String name = "";
    if (!anonymousClass) {
      name = tree.simpleName().name();
      flag = computeClassFlags(tree);
    }
    JavaSymbol.TypeJavaSymbol symbol = new JavaSymbol.TypeJavaSymbol(flag, name, env.scope.owner);
    symbol.declaration = tree;
    ((ClassTreeImpl) tree).setSymbol(symbol);
    //Only register classes that can be accessible, so classes owned by a method are not registered.
    //TODO : register also based on flags ?
    if (!anonymousClass) {
      if (env.scope.owner.kind == JavaSymbol.TYP || env.scope.owner.kind == JavaSymbol.PCK) {
        resolve.registerClass(symbol);
      }
      enterSymbol(tree, symbol);
    }
    symbol.members = new Scope(symbol);
    symbol.completer = completer;
    uncompleted.add(symbol);

    //Define type parameters:
    TypeParameters typeParameterTrees = tree.typeParameters();
    createNewEnvironment(typeParameterTrees);
    // Save current environment to be able to complete class later
    semanticModel.saveEnv(symbol, env);
    for (TypeParameterTree typeParameterTree : typeParameterTrees) {
      JavaSymbol.TypeVariableJavaSymbol typeVariableSymbol = new JavaSymbol.TypeVariableJavaSymbol(typeParameterTree.identifier().name(), symbol);
      symbol.addTypeParameter((TypeVariableJavaType) typeVariableSymbol.type);
      enterSymbol(typeParameterTree, typeVariableSymbol);
    }
    if(!typeParameterTrees.isEmpty()) {
      symbol.type = parametrizedTypeCache.getParametrizedTypeType(symbol, new TypeSubstitution());
    }
    symbol.typeParameters = env.scope;
    Resolve.Env classEnv = env.dup();
    classEnv.outer = env;
    classEnv.enclosingClass = symbol;
    classEnv.scope = symbol.members;
    env = classEnv;
    semanticModel.associateEnv(tree, env);
    scan(tree.modifiers());
    //skip type parameters
    scan(tree.superClass());
    scan(tree.superInterfaces());
    scan(tree.members());

    if (tree.is(Tree.Kind.ENUM)) {
      // implicit methods from enum: JLS8 : 8.9.2
      // add 'public static E[] values()'
      JavaSymbol.MethodJavaSymbol valuesMethod = new JavaSymbol.MethodJavaSymbol((symbol.flags & Flags.ACCESS_FLAGS) | Flags.STATIC, "values", symbol);
      ArrayJavaType enumArrayType = new ArrayJavaType(symbol.type, symbols.arrayClass);
      MethodJavaType valuesMethodType = new MethodJavaType(Collections.emptyList(), enumArrayType, Collections.emptyList(), symbol);
      valuesMethod.setMethodType(valuesMethodType);
      valuesMethod.parameters = new Scope(valuesMethod);
      classEnv.scope.enter(valuesMethod);

      // add 'public static E valueOf(String name)'
      JavaSymbol.MethodJavaSymbol valueOfMethod = new JavaSymbol.MethodJavaSymbol((symbol.flags & Flags.ACCESS_FLAGS) | Flags.STATIC, "valueOf", symbol);
      MethodJavaType valueOfMethodType = new MethodJavaType(Collections.singletonList(symbols.stringType), symbol.type, Collections.emptyList(), symbol);
      valueOfMethod.setMethodType(valueOfMethodType);
      valueOfMethod.parameters = new Scope(valueOfMethod);
      valueOfMethod.parameters.enter(new JavaSymbol.VariableJavaSymbol(0, "name", symbols.stringType, valueOfMethod));
      classEnv.scope.enter(valueOfMethod);
    }
    restoreEnvironment(tree);
    restoreEnvironment(tree);
  }

