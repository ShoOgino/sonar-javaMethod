  @Override
  public void visitClass(ClassTree tree) {
    int flag = 0;
    boolean anonymousClass = tree.simpleName() == null;
    String name = "";
    if (!anonymousClass) {
      name = tree.simpleName().name();
      flag = computeClassFlags(tree);
    }
    JavaSymbol.TypeJavaSymbol symbol = new JavaSymbol.TypeJavaSymbol(flag, name, env.scope.owner);
    symbol.declaration = tree;
    ((ClassTreeImpl) tree).setSymbol(symbol);
    //Only register classes that can be accessible, so classes owned by a method are not registered.
    //TODO : register also based on flags ?
    if (!anonymousClass) {
      if (env.scope.owner.kind == JavaSymbol.TYP || env.scope.owner.kind == JavaSymbol.PCK) {
        resolve.registerClass(symbol);
      }
      enterSymbol(tree, symbol);
    }
    symbol.members = new Scope(symbol);
    symbol.completer = completer;
    uncompleted.add(symbol);

    //Define type parameters:
    createNewEnvironment(tree.typeParameters());
    // Save current environment to be able to complete class later
    semanticModel.saveEnv(symbol, env);
    for (TypeParameterTree typeParameterTree : tree.typeParameters()) {
      JavaSymbol.TypeVariableJavaSymbol typeVariableSymbol = new JavaSymbol.TypeVariableJavaSymbol(typeParameterTree.identifier().name(), symbol);
      symbol.addTypeParameter((TypeVariableJavaType) typeVariableSymbol.type);
      enterSymbol(typeParameterTree, typeVariableSymbol);
    }
    symbol.typeParameters = env.scope;
    Resolve.Env classEnv = env.dup();
    classEnv.outer = env;
    classEnv.enclosingClass = symbol;
    classEnv.scope = symbol.members;
    env = classEnv;
    semanticModel.associateEnv(tree, env);
    scan(tree.modifiers());
    //skip type parameters
    scan(tree.superClass());
    scan(tree.superInterfaces());
    scan(tree.members());
    //Register default constructor
    if(tree.is(Tree.Kind.CLASS) && classEnv.scope.lookup(CONSTRUCTOR_NAME).isEmpty()) {
      JavaSymbol.MethodJavaSymbol defaultConstructor = new JavaSymbol.MethodJavaSymbol(symbol.flags & Flags.ACCESS_FLAGS, CONSTRUCTOR_NAME, symbol);
      MethodJavaType defaultConstructorType = new MethodJavaType(ImmutableList.<JavaType>of(), null, ImmutableList.<JavaType>of(), symbol);
      defaultConstructor.setMethodType(defaultConstructorType);
      classEnv.scope.enter(defaultConstructor);
    } else if (tree.is(Tree.Kind.ENUM)) {
      // implicit methods from enum: JLS8 : 8.9.2
      // add 'public static E[] values()'
      JavaSymbol.MethodJavaSymbol valuesMethod = new JavaSymbol.MethodJavaSymbol((symbol.flags & Flags.ACCESS_FLAGS) | Flags.STATIC, "values", symbol);
      ArrayJavaType enumArrayType = new ArrayJavaType(symbol.type, symbols.arrayClass);
      MethodJavaType valuesMethodType = new MethodJavaType(ImmutableList.<JavaType>of(), enumArrayType, ImmutableList.<JavaType>of(), symbol);
      valuesMethod.setMethodType(valuesMethodType);
      classEnv.scope.enter(valuesMethod);

      // add 'public static E valueOf(String name)'
      JavaSymbol.MethodJavaSymbol valueOfMethod = new JavaSymbol.MethodJavaSymbol((symbol.flags & Flags.ACCESS_FLAGS) | Flags.STATIC, "valueOf", symbol);
      MethodJavaType valueOfMethodType = new MethodJavaType(ImmutableList.<JavaType>of(symbols.stringType), symbol.type, ImmutableList.<JavaType>of(), symbol);
      valueOfMethod.setMethodType(valueOfMethodType);
      classEnv.scope.enter(valueOfMethod);
    }
    restoreEnvironment(tree);
    restoreEnvironment(tree);
  }

