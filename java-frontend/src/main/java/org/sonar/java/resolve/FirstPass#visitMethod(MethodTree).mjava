  @Override
  public void visitMethod(MethodTree tree) {
    String name = tree.returnType() == null ? CONSTRUCTOR_NAME : tree.simpleName().name();
    JavaSymbol.MethodJavaSymbol symbol = new JavaSymbol.MethodJavaSymbol(computeFlags(tree.modifiers(), tree), name, env.scope.owner);
    symbol.declaration = tree;
    if (Flags.isFlagged(env.scope.owner.flags, Flags.ENUM) && tree.returnType() == null) {
      //enum constructors are private.
      symbol.flags |= Flags.PRIVATE;
    }
    enterSymbol(tree, symbol);
    symbol.parameters = new Scope(symbol);
    symbol.completer = completer;
    uncompleted.add(symbol);

    ((MethodTreeImpl) tree).setSymbol(symbol);
    createNewEnvironment(tree.typeParameters());
    for (TypeParameterTree typeParameterTree : tree.typeParameters()) {
      JavaSymbol.TypeVariableJavaSymbol typeVariableSymbol = new JavaSymbol.TypeVariableJavaSymbol(typeParameterTree.identifier().name(), symbol);
      symbol.addTypeParameter((TypeVariableJavaType) typeVariableSymbol.type);
      enterSymbol(typeParameterTree, typeVariableSymbol);
    }
    // Save current environment to be able to complete method later
    semanticModel.saveEnv(symbol, env);

    symbol.typeParameters = env.scope;
    // Create new environment - this is required, because new scope is created
    Resolve.Env methodEnv = env.dup();
    methodEnv.scope = symbol.parameters;
    methodEnv.outer = env;
    env = methodEnv;
    scan(tree.modifiers());
    //skip type parameters.
    scan(tree.returnType());
    scan(tree.parameters());
    scan(tree.throwsClauses());
    scan(tree.defaultValue());
    symbol.defaultValue = getDefaultValueFromTree(tree.defaultValue());
    scan(tree.block());
    restoreEnvironment(tree);
    restoreEnvironment(tree);
  }

