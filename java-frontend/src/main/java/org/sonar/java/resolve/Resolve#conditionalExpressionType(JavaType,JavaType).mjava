  public JavaType conditionalExpressionType(JavaType trueType, JavaType falseType) {
    if (trueType == falseType) {
      return trueType;
    }
    if (isNullAndPrimitive(trueType, falseType)) {
      return falseType.isPrimitive() ? falseType.primitiveWrapperType() : falseType;
    }
    if (isNullAndPrimitive(falseType, trueType)) {
      return trueType.isPrimitive() ? trueType.primitiveWrapperType() : trueType;
    }
    JavaType secondOperand = getPrimitive(trueType);
    JavaType thirdOperand = getPrimitive(falseType);
    if (secondOperand != null && thirdOperand != null && isNumericalConditionalExpression(secondOperand, thirdOperand)) {
      // If operand is a constant int that can fits a narrow type it should be narrowed. We always narrow to approximate things properly for
      // method resolution.
      if ((secondOperand.tag < thirdOperand.tag || secondOperand.isTagged(JavaType.INT)) && !thirdOperand.isTagged(JavaType.INT)) {
        return thirdOperand;
      } else {
        return secondOperand;
      }
    }
    return (JavaType) leastUpperBound(Lists.<Type>newArrayList(trueType, falseType));
  }

