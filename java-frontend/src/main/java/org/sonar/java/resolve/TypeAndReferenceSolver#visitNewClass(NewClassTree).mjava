  @Override
  public void visitNewClass(NewClassTree tree) {
    Resolve.Env newClassEnv = semanticModel.getEnv(tree);
    ExpressionTree enclosingExpression = tree.enclosingExpression();
    NewClassTreeImpl newClassTreeImpl = (NewClassTreeImpl) tree;
    if (enclosingExpression != null) {
      resolveAs(enclosingExpression, JavaSymbol.VAR);
      Resolve.Resolution idType = resolve.findIdentInType(newClassEnv, (JavaSymbol.TypeJavaSymbol) enclosingExpression.symbolType().symbol(), newClassTreeImpl.getConstructorIdentifier().name(), JavaSymbol.TYP);
      registerType(tree.identifier(), idType.type());
    } else {
      resolveAs(tree.identifier(), JavaSymbol.TYP, newClassEnv, false);
    }

    if (tree.typeArguments() != null) {
      resolveAs((List<Tree>) tree.typeArguments(), JavaSymbol.TYP);
    }
    resolveAs((List<ExpressionTree>) tree.arguments(), JavaSymbol.VAR);
    resolveConstructorSymbol(newClassTreeImpl.getConstructorIdentifier(), newClassTreeImpl.identifier().symbolType(), newClassEnv, getParameterTypes(tree.arguments()));
    ClassTree classBody = tree.classBody();
    if (classBody != null) {
      JavaType type = (JavaType) tree.identifier().symbolType();
      JavaType.ClassJavaType anonymousClassType = (JavaType.ClassJavaType) classBody.symbol().type();
      if (type.getSymbol().isFlag(Flags.INTERFACE)) {
        anonymousClassType.interfaces = ImmutableList.of(type);
        anonymousClassType.supertype = symbols.objectType;
      } else {
        anonymousClassType.supertype = type;
        anonymousClassType.interfaces = ImmutableList.of();
      }
      scan(classBody);
      registerType(tree, anonymousClassType);
    } else {
      registerType(tree, getType(tree.identifier()));
    }
  }

