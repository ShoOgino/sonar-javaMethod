  @Override
  public void visitNewClass(NewClassTree tree) {
    NewClassTreeImpl newClassTreeImpl = (NewClassTreeImpl) tree;
    if (newClassTreeImpl.isTypeSet()) {
      return;
    }
    List<JavaType> typeArgumentsTypes = Collections.emptyList();
    if (tree.typeArguments() != null) {
      resolveAs((List<Tree>) tree.typeArguments(), JavaSymbol.TYP);
      typeArgumentsTypes = tree.typeArguments().stream().map(this::getType).collect(Collectors.toList());
    }
    resolveAs((List<ExpressionTree>) tree.arguments(), JavaSymbol.VAR);
    List<JavaType> parameterTypes = getParameterTypes(tree.arguments());
    Resolve.Env newClassEnv = semanticModel.getEnv(tree);
    ExpressionTree enclosingExpression = tree.enclosingExpression();

    TypeTree typeTree = tree.identifier();
    IdentifierTree constructorIdentifier = newClassTreeImpl.getConstructorIdentifier();
    JavaType identifierType = resolveIdentifierType(newClassEnv, enclosingExpression, typeTree, constructorIdentifier.name());
    JavaSymbol.TypeJavaSymbol constructorIdentifierSymbol = (JavaSymbol.TypeJavaSymbol) identifierType.symbol();
    constructorIdentifierSymbol.addUsage(constructorIdentifier);
    parameterTypes = addImplicitOuterClassParameter(parameterTypes, constructorIdentifierSymbol);
    Resolution resolution = resolveConstructorSymbol(constructorIdentifier, identifierType, newClassEnv, parameterTypes, typeArgumentsTypes);
    JavaType constructedType = identifierType;
    if (resolution.symbol().isMethodSymbol()) {
      constructedType = ((MethodJavaType) resolution.type()).resultType;
      if (constructedType.isTagged(JavaType.DEFERRED)) {
        Tree parent = newClassTreeImpl.parent();
        if (parent.is(Tree.Kind.MEMBER_SELECT)) {
          constructedType = resolve.parametrizedTypeWithErasure((ParametrizedTypeJavaType) identifierType);
        } else {
          // will be resolved by type inference
          ((DeferredType) constructedType).setTree(newClassTreeImpl);
        }
      } else if (identifierType.symbol().isInterface()) {
        // constructor of interface always resolve to 'Object' no-arg constructor
        registerType(typeTree, identifierType);
      } else {
        registerType(typeTree, resolution.type());
      }
    }
    ClassTree classBody = tree.classBody();
    if (classBody != null) {
      constructedType = getAnonymousClassType(identifierType, constructedType, classBody);
    }
    registerType(tree, constructedType);
  }

