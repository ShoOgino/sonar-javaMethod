  @Override
  public void visitNewClass(NewClassTree tree) {
    NewClassTreeImpl newClassTreeImpl = (NewClassTreeImpl) tree;
    if (newClassTreeImpl.isTypeSet()) {
      return;
    }
    List<JavaType> typeArgumentsTypes = ImmutableList.of();
    if (tree.typeArguments() != null) {
      resolveAs((List<Tree>) tree.typeArguments(), JavaSymbol.TYP);
      typeArgumentsTypes = tree.typeArguments().stream().map(this::getType).collect(Collectors.toList());
    }
    resolveAs((List<ExpressionTree>) tree.arguments(), JavaSymbol.VAR);
    List<JavaType> parameterTypes = getParameterTypes(tree.arguments());
    Resolve.Env newClassEnv = semanticModel.getEnv(tree);
    ExpressionTree enclosingExpression = tree.enclosingExpression();

    TypeTree typeTree = tree.identifier();
    IdentifierTree constructorIdentifier = newClassTreeImpl.getConstructorIdentifier();
    JavaType identifierType = resolveIdentifierType(newClassEnv, enclosingExpression, typeTree, constructorIdentifier.name());
    JavaSymbol.TypeJavaSymbol constructorIdentifierSymbol = (JavaSymbol.TypeJavaSymbol) identifierType.symbol();
    parameterTypes = addImplicitOuterClassParameter(parameterTypes, constructorIdentifierSymbol);
    Resolution resolution = resolveConstructorSymbol(constructorIdentifier, identifierType, newClassEnv, parameterTypes, typeArgumentsTypes);
    ClassTree classBody = tree.classBody();
    JavaType constructedType = identifierType;
    if (classBody != null) {
      ClassJavaType anonymousClassType = (ClassJavaType) classBody.symbol().type();
      if (identifierType.getSymbol().isInterface()) {
        anonymousClassType.interfaces = ImmutableList.of(identifierType);
        anonymousClassType.supertype = symbols.objectType;
      } else {
        anonymousClassType.supertype = identifierType;
        anonymousClassType.interfaces = ImmutableList.of();
      }
      scan(classBody);
      constructedType = anonymousClassType;
    } else if (resolution.symbol().isMethodSymbol()) {
      constructedType = ((MethodJavaType) resolution.type()).resultType;
      if (constructedType.isTagged(JavaType.DEFERRED)) {
        Tree parent = newClassTreeImpl.parent();
        if (parent.is(Tree.Kind.MEMBER_SELECT)) {
          constructedType = resolve.parametrizedTypeWithErasure((ParametrizedTypeJavaType) identifierType);
        } else {
          // will be resolved by type inference
          ((DeferredType) constructedType).setTree(newClassTreeImpl);
        }
      }
    }
    registerType(tree, constructedType);
  }

