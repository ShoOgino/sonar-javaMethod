  @Override
  public void visitNewClass(NewClassTree tree) {
    NewClassTreeImpl newClassTreeImpl = (NewClassTreeImpl) tree;
    if (newClassTreeImpl.isTypeSet()) {
      return;
    }
    Resolve.Env newClassEnv = semanticModel.getEnv(tree);
    ExpressionTree enclosingExpression = tree.enclosingExpression();
    if (enclosingExpression != null) {
      resolveAs(enclosingExpression, JavaSymbol.VAR);
      Resolve.Resolution idType = resolve.findIdentInType(newClassEnv, (JavaSymbol.TypeJavaSymbol) enclosingExpression.symbolType().symbol(),
        newClassTreeImpl.getConstructorIdentifier().name(), JavaSymbol.TYP);
      registerType(tree.identifier(), idType.type());
    } else {
      resolveAs(tree.identifier(), JavaSymbol.TYP, newClassEnv, false);
    }

    if (tree.typeArguments() != null) {
      resolveAs((List<Tree>) tree.typeArguments(), JavaSymbol.TYP);
    }
    resolveAs((List<ExpressionTree>) tree.arguments(), JavaSymbol.VAR);
    // FIXME SONARJAVA-1667 type arguments should not be ignored for the resolution of the constructor
    Resolution resolution =
      resolveConstructorSymbol(newClassTreeImpl.getConstructorIdentifier(), newClassTreeImpl.identifier().symbolType(), newClassEnv, getParameterTypes(tree.arguments()));
    ClassTree classBody = tree.classBody();
    if (classBody != null) {
      JavaType type = (JavaType) tree.identifier().symbolType();
      ClassJavaType anonymousClassType = (ClassJavaType) classBody.symbol().type();
      if (type.getSymbol().isFlag(Flags.INTERFACE)) {
        anonymousClassType.interfaces = ImmutableList.of(type);
        anonymousClassType.supertype = symbols.objectType;
      } else {
        anonymousClassType.supertype = type;
        anonymousClassType.interfaces = ImmutableList.of();
      }
      scan(classBody);
      registerType(tree, anonymousClassType);
    } else {
      JavaType returnType;
      if (resolution.symbol().isMethodSymbol()) {
        returnType = ((MethodJavaType) resolution.type()).resultType;
        if (returnType.isTagged(JavaType.DEFERRED)) {
          Tree parent = newClassTreeImpl.parent();
          if (parent.is(Tree.Kind.MEMBER_SELECT)) {
            returnType = resolve.parametrizedTypeWithErasure((ParametrizedTypeJavaType) getType(tree.identifier()));
          } else {
            // will be resolved by type inference
            ((DeferredType) returnType).setTree(newClassTreeImpl);
          }
        }
      } else {
        returnType = getType(tree.identifier());
      }
      registerType(tree, returnType);
    }
  }

