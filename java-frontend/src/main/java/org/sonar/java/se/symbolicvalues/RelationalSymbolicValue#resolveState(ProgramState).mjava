  RelationState resolveState(ProgramState programState) {
    if (hasSameOperand()) {
      return relationStateForSameOperand();
    }

    Set<RelationalSymbolicValue> allRelations = knownRelations(programState).collect(Collectors.toCollection(HashSet::new));
    Deque<RelationalSymbolicValue> workList = new ArrayDeque<>(allRelations);
    int iterations = 0;
    while (!workList.isEmpty()) {
      if (allRelations.size() > MAX_DEDUCED_RELATIONS || iterations > MAX_ITERATIONS) {
        // safety mechanism in case of an error in the algorithm
        // should not happen under normal conditions
        throw new RelationalSymbolicValue.TransitiveRelationExceededException("Used relations: " + allRelations.size() + ". Iterations " + iterations);
      }
      iterations++;
      RelationalSymbolicValue relation = workList.pop();
      RelationState result = relation.implies(this);
      if (result.isDetermined()) {
        return result;
      }
      List<RelationalSymbolicValue> newRelations = allRelations.stream()
        .map(relation::deduceTransitiveOrSimplified)
        .filter(Objects::nonNull)
        .filter(r -> !allRelations.contains(r))
        .collect(Collectors.toList());

      allRelations.addAll(newRelations);
      workList.addAll(newRelations);
    }
    return RelationState.UNDETERMINED;
  }

