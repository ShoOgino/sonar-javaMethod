  public ProgramState cleanupConstraints() {
    class CleanAction implements BiConsumer<SymbolicValue, Constraint> {
      boolean newProgramState = false;
      PMap<SymbolicValue, Constraint> newConstraints = constraints;
      PMap<SymbolicValue, Integer> newReferences = references;

      @Override
      public void accept(SymbolicValue symbolicValue, Constraint constraint) {
        if (!isReachable(symbolicValue, newReferences) && isDisposable(symbolicValue, constraint) && !inStack(stack, symbolicValue)) {
          newProgramState = true;
          newConstraints = newConstraints.remove(symbolicValue);
          newReferences = newReferences.remove(symbolicValue);
        }
      }
    }
    CleanAction cleanAction = new CleanAction();
    constraints.forEach(cleanAction);
    return cleanAction.newProgramState ? new ProgramState(values, cleanAction.newReferences, cleanAction.newConstraints, visitedPoints, stack, exitSymbolicValue) : this;
  }

