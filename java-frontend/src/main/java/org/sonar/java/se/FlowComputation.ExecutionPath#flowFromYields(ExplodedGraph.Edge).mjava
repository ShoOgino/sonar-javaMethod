    private Set<List<JavaFileScannerContext.Location>> flowFromYields(ExplodedGraph.Edge edge) {
      Set<MethodYield> methodYields = edge.yields();
      if (methodYields.isEmpty()) {
        // return one flow with no elements, nothing will be added to the flow of the current path
        // but this is necessary so path is returned in #addEdge and stays in the worklist in #run
        return ImmutableSet.of(ImmutableList.of());
      }

      List<Integer> argumentIndices = correspondingArgumentIndices(symbolicValues, edge.parent);

      MethodInvocationTree mit = (MethodInvocationTree) edge.parent.programPoint.syntaxTree();
      // computes flow messages for arguments being passed to the called method
      List<JavaFileScannerContext.Location> passedArgumentsMessages = flowsForPassedArguments(argumentIndices, mit);
      // computes flow messages for arguments changing name within called method
      List<JavaFileScannerContext.Location> changingNameArgumentsMessages = flowsForArgumentsChangingName(argumentIndices, mit);

      SymbolicValue returnSV = edge.child.programState.peekValue();
      if (symbolicValues.contains(returnSV)) {
        // to retrieve flow for return value
        argumentIndices.add(-1);
      }
      if (argumentIndices.isEmpty()) {
        // no need to compute any flow on yields : no arg nor return value are corresponding to tracked SVs
        return ImmutableSet.of(ImmutableList.of());
      }
      return methodYields.stream()
        .map(y -> y.flow(argumentIndices, domains))
        .flatMap(Set::stream)
        .map(flowFromYield -> ImmutableList.<JavaFileScannerContext.Location>builder()
          .addAll(flowFromYield)
          .addAll(changingNameArgumentsMessages)
          .addAll(passedArgumentsMessages)
          .build())
        .collect(Collectors.toSet());
    }

