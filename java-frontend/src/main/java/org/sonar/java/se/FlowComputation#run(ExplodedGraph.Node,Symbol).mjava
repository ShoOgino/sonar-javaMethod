  private void run(@Nullable final ExplodedGraph.Node node, @Nullable final Symbol trackSymbol) {
    Deque<NodeSymbol> workList = new ArrayDeque<>();
    workList.add(new NodeSymbol(node, trackSymbol));
    while (!workList.isEmpty()) {
      NodeSymbol nodeSymbol = workList.pop();
      ExplodedGraph.Node currentNode = nodeSymbol.node;
      if (currentNode == null || visited.contains(currentNode)) {
        continue;
      }
      visited.add(currentNode);

      Symbol newTrackSymbol = nodeSymbol.trackSymbol;
      if (currentNode.programPoint.syntaxTree() != null) {
        newTrackSymbol = addFlowFromLearnedAssociations(currentNode, newTrackSymbol);
        Stream<Constraint> learnedConstraints = addFlowFromLearnedConstraints(currentNode);
        if (learnedConstraints.anyMatch(terminateTraversal)) {
          continue;
        }
      }
      for (ExplodedGraph.Node parent : currentNode.parents()) {
        workList.push(new NodeSymbol(parent, newTrackSymbol));
      }
    }
  }

