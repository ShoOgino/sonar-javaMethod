    private Stream<JavaFileScannerContext.Location> methodInvocationFlow(Constraint learnedConstraint, ExplodedGraph.Edge edge) {
      ExplodedGraph.Node parent = edge.parent;
      MethodInvocationTree mit = (MethodInvocationTree) parent.programPoint.syntaxTree();
      Stream.Builder<JavaFileScannerContext.Location> flowBuilder = Stream.builder();
      SymbolicValue returnSV = edge.child.programState.peekValue();
      if (symbolicValues.contains(returnSV)) {
        flowBuilder.add(location(parent, String.format("'%s()' returns %s.", mit.symbol().name(), learnedConstraint.valueAsString())));
      }
      SymbolicValue invocationTarget = parent.programState.peekValue(mit.arguments().size());
      if (symbolicValues.contains(invocationTarget)) {
        flowBuilder.add(location(parent, "..."));
      }

      List<Integer> argumentIndices = correspondingArgumentIndices(symbolicValues, parent);
      argumentIndices.stream()
        .map(mit.arguments()::get)
        .map(argTree -> {
          String message = String.format("Implies '%s' is %s.", SyntaxTreeNameFinder.getName(argTree), learnedConstraint.valueAsString());
          return new JavaFileScannerContext.Location(message, argTree);
        })
        .forEach(flowBuilder::add);

      MethodYield selectedMethodYield = edge.child.selectedMethodYield(parent);
      if (selectedMethodYield != null) {
        if (symbolicValues.contains(returnSV)) {
          // to retrieve flow for return value
          argumentIndices.add(-1);
        }
        // FIXME SONARJAVA-2076 consider all flows from yields
        selectedMethodYield.flow(argumentIndices, domains).stream()
          .limit(1)
          .flatMap(List::stream)
          .forEach(flowBuilder::add);
      }
      return flowBuilder.build();
    }

