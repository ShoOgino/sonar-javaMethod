    Stream<ExecutionPath> addEdge(ExplodedGraph.Edge edge) {
      ImmutableList.Builder<JavaFileScannerContext.Location> flowBuilder = ImmutableList.builder();
      flowBuilder.addAll(flow);

      List<JavaFileScannerContext.Location> laFlow = learnedAssociation(edge)
        .map(la -> flowFromLearnedAssociation(la, edge.parent))
        .orElse(ImmutableList.of());
      flowBuilder.addAll(laFlow);

      PSet<Symbol> newTrackSymbols = newTrackedSymbols(edge);
      SameConstraints newSameConstraints = newTrackSymbols == trackedSymbols ? sameConstraints : new SameConstraints(sameConstraints, newTrackSymbols);

      flowFromThrownException(edge).ifPresent(flowBuilder::add);

      Set<LearnedConstraint> learnedConstraints = learnedConstraints(edge);
      List<JavaFileScannerContext.Location> lcFlow = flowFromLearnedConstraints(edge, filterRedundantObjectDomain(learnedConstraints));
      flowBuilder.addAll(lcFlow);

      boolean endOfPath = visitedAllParents(edge) || shouldTerminate(learnedConstraints);

      if (endOfPath) {
        flowBuilder.addAll(flowForNullableMethodParameters(edge.parent));
      }

      List<JavaFileScannerContext.Location> currentFlow = flowBuilder.build();
      Set<List<JavaFileScannerContext.Location>> yieldsFlows = flowFromYields(edge);
      if (yieldsFlows.isEmpty()) {
        return Stream.of(new ExecutionPath(edge, visited.add(edge), newTrackSymbols, newSameConstraints, ImmutableList.copyOf(currentFlow), endOfPath));
      }
      return yieldsFlows.stream()
        .map(yieldFlow -> ImmutableList.<JavaFileScannerContext.Location>builder().addAll(currentFlow).addAll(yieldFlow).build())
        .map(f -> new ExecutionPath(edge, visited.add(edge), newTrackSymbols, newSameConstraints, f, endOfPath));
    }

