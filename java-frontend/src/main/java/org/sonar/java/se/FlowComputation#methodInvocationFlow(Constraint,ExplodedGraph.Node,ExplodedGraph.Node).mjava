  private Stream<JavaFileScannerContext.Location> methodInvocationFlow(Constraint learnedConstraint, ExplodedGraph.Node currentNode, ExplodedGraph.Node parent) {
    MethodInvocationTree mit = (MethodInvocationTree) parent.programPoint.syntaxTree();
    Stream.Builder<JavaFileScannerContext.Location> flowBuilder = Stream.builder();
    SymbolicValue returnSV = currentNode.programState.peekValue();
    if (symbolicValues.contains(returnSV)) {
      flowBuilder.add(location(parent, String.format("'%s()' returns %s.", mit.symbol().name(), learnedConstraint.valueAsString())));
    }
    SymbolicValue invocationTarget = parent.programState.peekValue(mit.arguments().size());
    if (symbolicValues.contains(invocationTarget)) {
      flowBuilder.add(location(parent, "..."));
    }
    int argIdx = correspondingArgumentIndex(symbolicValues, parent);
    if (argIdx != -1) {
      ExpressionTree argTree = mit.arguments().get(argIdx);
      String message = String.format("Implies '%s' is %s.", SyntaxTreeNameFinder.getName(argTree), learnedConstraint.valueAsString());
      flowBuilder.add(new JavaFileScannerContext.Location(message, argTree));
    }
    MethodYield selectedMethodYield = currentNode.selectedMethodYield(parent);
    if (selectedMethodYield != null) {
      Set<List<JavaFileScannerContext.Location>> xProcFlows = selectedMethodYield.flow(argIdx, domains);
      // FIXME SONARJAVA-2076 consider all flows from yields
      xProcFlows.stream().findFirst().ifPresent(f -> f.forEach(flowBuilder::add));
    }
    return flowBuilder.build();
  }

