  public Collection<ProgramState> statesAfterInvocation(List<SymbolicValue> invocationArguments, ProgramState programState, Supplier<SymbolicValue> svSupplier) {
    Set<ProgramState> results = new LinkedHashSet<>();
    for (int index = 0; index < invocationArguments.size(); index++) {
      // FIXME : varargs method should be handled
      SymbolicValue invokedArg = invocationArguments.get(index);
      Constraint constraint = parametersConstraints[Math.min(index, parametersConstraints.length - 1)];
      if (constraint == null) {
        // no constraint on this parameter, let's try next one.
        continue;
      }

      Set<ProgramState> programStates = programStatesForConstraint(results.isEmpty() ? Lists.newArrayList(programState) : results, invokedArg, constraint);
      if (programStates.isEmpty()) {
        // constraint can't be satisfied, no need to process things further, this yield is not applicable.
        // TODO there might be some issue to report in this case.
        return programStates;
      }
      results.addAll(programStates);
    }

    // resulting program states can be empty if all constraints on params are null or if method has no arguments.
    // That means that this yield is still possible and we need to stack a returned SV with its eventual constraints.
    if(results.isEmpty()) {
      results.add(programState);
    }

    // applied all constraints from parameters, stack return value
    SymbolicValue sv;
    if (resultIndex < 0) {
      sv = svSupplier.get();
    } else {
      // returned SV is the same as one of the arguments.
      sv = invocationArguments.get(resultIndex);
    }
    Stream<ProgramState> stateStream = results.stream().map(s -> s.stackValue(sv));
    if (resultConstraint != null) {
      stateStream = stateStream.map(s -> s.addConstraint(sv, resultConstraint));
    }
    return stateStream.collect(Collectors.toCollection(LinkedHashSet::new));
  }

