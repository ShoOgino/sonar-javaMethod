  public List<ProgramState> statesAfterInvocation(List<SymbolicValue> invocationArguments, ProgramState programState, Supplier<SymbolicValue> svSupplier) {
    List<ProgramState> results = new ArrayList<>();
    results.add(programState);
    for (int index = 0; index < invocationArguments.size(); index++) {
      // FIXME : varargs method should be handled
      SymbolicValue invokedArg = invocationArguments.get(index);
      Constraint constraint = parametersConstraints[Math.min(index, parametersConstraints.length - 1)];
      if (constraint == null) {
        // no constraint on this parameter, let's try next one.
        continue;
      }

      List<ProgramState> programStates = new ArrayList<>();
      if (constraint instanceof ObjectConstraint) {
        for (ProgramState state : results) {
          programStates.addAll(invokedArg.setConstraint(state, (ObjectConstraint) constraint));
        }
      } else if (constraint instanceof BooleanConstraint) {
        for (ProgramState state : results) {
          programStates.addAll(invokedArg.setConstraint(state, (BooleanConstraint) constraint));
        }
      }
      if (programStates.isEmpty()) {
        // constraint can't be satisfied, no need to process things further, this yield is not applicable.
        // TODO there might be some issue to report in this case.
        return programStates;
      }
      results.addAll(programStates);
    }

    if (exception) {
      return results;
    }
    // applied all constraints from parameters, stack return value
    SymbolicValue sv;
    if (resultIndex < 0) {
      sv = svSupplier.get();
    } else {
      // returned SV is the same as one of the arguments.
      sv = invocationArguments.get(resultIndex);
    }
    Stream<ProgramState> stateStream = results.stream().map(s -> s.stackValue(sv));
    if (resultConstraint != null) {
      stateStream = stateStream.map(s -> s.addConstraint(sv, resultConstraint));
    }
    return stateStream.collect(Collectors.toList());
  }

