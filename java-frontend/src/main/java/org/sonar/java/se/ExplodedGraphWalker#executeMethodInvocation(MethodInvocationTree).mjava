  private void executeMethodInvocation(MethodInvocationTree mit) {
    setSymbolicValueOnFields(mit);
    // unstack arguments and method identifier
    ProgramState.Pop unstack = programState.unstackValue(mit.arguments().size() + 1);
    logState(mit);

    programState = unstack.state;

    // get method behavior for method with known declaration (ie: within the same file)
    MethodBehavior methodInvokedBehavior = null;
    Symbol methodSymbol = mit.symbol();
    Tree declaration = methodSymbol.declaration();
    if(declaration != null) {
      methodInvokedBehavior = symbolicExecutionVisitor.execute((MethodTree) declaration);
    }
    final SymbolicValue resultValue = constraintManager.createMethodSymbolicValue(mit, unstack.values);
    if (methodInvokedBehavior != null && methodInvokedBehavior.isComplete() && methodCanNotBeOverriden(methodSymbol)) {
      List<SymbolicValue> invocationArguments = invocationArguments(unstack.values);
      List<Type> invocationTypes = mit.arguments().stream().map(ExpressionTree::symbolType).collect(Collectors.toList());

      methodInvokedBehavior.exceptionalPathYields()
        .flatMap(yield -> yield.statesAfterInvocation(invocationArguments, invocationTypes, programState, () -> resultValue).stream())
        .forEach(this::enqueueExceptionalPaths);

      methodInvokedBehavior.happyPathYields()
        .flatMap(yield -> yield.statesAfterInvocation(invocationArguments, invocationTypes, programState, () -> resultValue).stream())
        .forEach(psYield -> {
          ProgramState ps = psYield;
          if (isNonNullMethod(methodSymbol)) {
            ps = ps.addConstraint(ps.peekValue(), ObjectConstraint.NOT_NULL);
          } else if (OBJECT_WAIT_MATCHER.matches(mit)) {
            ps = ps.resetFieldValues(constraintManager);
          }
          checkerDispatcher.syntaxNode = mit;
          checkerDispatcher.addTransition(ps);
          clearStack(mit);
        });
    } else {
      enqueueExceptionalPaths(programState);

      programState = programState.stackValue(resultValue);
      if (isNonNullMethod(methodSymbol)) {
        programState = programState.addConstraint(resultValue, ObjectConstraint.NOT_NULL);
      } else if (OBJECT_WAIT_MATCHER.matches(mit)) {
        programState = programState.resetFieldValues(constraintManager);
      }
      checkerDispatcher.executeCheckPostStatement(mit);
      clearStack(mit);
    }
  }

