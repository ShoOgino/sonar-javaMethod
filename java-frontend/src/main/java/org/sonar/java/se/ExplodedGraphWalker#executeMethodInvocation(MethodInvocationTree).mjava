  private void executeMethodInvocation(MethodInvocationTree mit) {
    setSymbolicValueOnFields(mit);
    // unstack arguments and method identifier
    ProgramState.Pop unstack = programState.unstackValue(mit.arguments().size() + 1);
    logState(mit);

    programState = unstack.state;

    // get method behavior for method with known declaration (ie: within the same file)
    MethodBehavior methodInvokedBehavior = null;
    Symbol methodSymbol = mit.symbol();
    if(methodSymbol.isMethodSymbol()) {
      methodInvokedBehavior = behaviorCache.get((Symbol.MethodSymbol) methodSymbol);
    }

    // Enqueue additional exceptional paths corresponding to unchecked exceptions, for instance OutOfMemoryError
    enqueueUncheckedExceptionalPaths();

    final SymbolicValue resultValue = constraintManager.createMethodSymbolicValue(mit, unstack.values);
    if (methodInvokedBehavior != null && methodInvokedBehavior.isComplete()) {
      List<SymbolicValue> invocationArguments = invocationArguments(unstack.values);
      List<Type> invocationTypes = mit.arguments().stream().map(ExpressionTree::symbolType).collect(Collectors.toList());

      Map<Type, SymbolicValue.ExceptionalSymbolicValue> thrownExceptionsByExceptionType = new HashMap<>();

      // Enqueue exceptional paths from exceptional yields
      methodInvokedBehavior.exceptionalPathYields()
        .forEach(yield -> yield.statesAfterInvocation(
          invocationArguments,
          invocationTypes,
          programState,
          () -> thrownExceptionsByExceptionType.computeIfAbsent(yield.exceptionType, constraintManager::createExceptionalSymbolicValue))
        .forEach(psYield -> enqueueExceptionalPaths(psYield, yield)));

      // Enqueue happy paths
      methodInvokedBehavior.happyPathYields()
        .flatMap(yield -> yield.statesAfterInvocation(invocationArguments, invocationTypes, programState, () -> resultValue))
        .map(psYield -> handleSpecialMethods(psYield, mit))
        .forEach(psYield -> {
          checkerDispatcher.syntaxNode = mit;
          checkerDispatcher.addTransition(psYield);
          clearStack(mit);
        });
    } else {
      // Enqueue exceptional paths from thrown exceptions
      enqueueThrownExceptionalPaths(methodSymbol);

      // Enqueue happy paths
      programState = handleSpecialMethods(programState.stackValue(resultValue), mit);
      checkerDispatcher.executeCheckPostStatement(mit);
      clearStack(mit);
    }
  }

