  private JavaCharacter parseJavaEscapeSequence(JavaCharacter backslash) {
    unicodeProcessedCharacters.moveNext();
    JavaCharacter javaCharacter = unicodeProcessedCharacters.getCurrent();
    if (javaCharacter == null) {
      // Should only happen in case of syntactically invalid string literals
      return backslash;
    }
    char ch = javaCharacter.getCharacter();
    switch (ch) {
      case 'n':
        ch = '\n';
        break;
      case 'r':
        ch = '\r';
        break;
      case 'f':
        ch = '\f';
        break;
      case 'b':
        ch = '\b';
        break;
      case 't':
        ch = '\t';
        break;
      default:
        if (isOctalDigit(ch)) {
          StringBuilder codeUnit = new StringBuilder(3);
          for (int i = 0; i < 3 && javaCharacter != null && isOctalDigit(javaCharacter.getCharacter()); i++) {
            codeUnit.append(javaCharacter.getCharacter());
            unicodeProcessedCharacters.moveNext();
            javaCharacter = unicodeProcessedCharacters.getCurrent();
          }
          ch = (char) Integer.parseInt(codeUnit.toString(), 8);
          int endIndex = javaCharacter == null ? source.length() : javaCharacter.getRange().getBeginningOffset();
          return new JavaCharacter(source, backslash.getRange().extendTo(endIndex), ch);
        }
        break;
    }
    unicodeProcessedCharacters.moveNext();
    return new JavaCharacter(source, backslash.getRange().merge(javaCharacter.getRange()), ch);
  }

