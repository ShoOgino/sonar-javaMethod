  @CheckForNull
  private CharacterClassElementTree parseCharacterClassElement(boolean isAtBeginning) {
    if (characters.isInQuotingMode() && characters.isNotAtEnd()) {
      return readCharacter();
    }
    if (characters.isAtEnd() || characters.currentIs("&&")) {
      return null;
    }
    SourceCharacter startCharacter = characters.getCurrent();
    switch (startCharacter.getCharacter()) {
      case '\\':
        RegexTree escape = parseEscapeSequence();
        if (escape.is(RegexTree.Kind.CHARACTER)) {
          return parseCharacterRange((CharacterTree) escape);
        } else if (escape instanceof CharacterClassElementTree) {
          return (CharacterClassElementTree) escape;
        } else {
          errors.add(new SyntaxError(escape, "Invalid escape sequence inside character class"));
          // Produce dummy AST and keep parsing to catch more errors.
          // The 'x' here doesn't matter because we're not going to actually use the AST when there are syntax errors.
          return characterTree(new SourceCharacter(source, escape.getRange(), 'x'));
        }
      case '[':
        return parseCharacterClass();
      case ']':
        if (isAtBeginning) {
          characters.moveNext();
          return parseCharacterRange(characterTree(startCharacter));
        } else {
          return null;
        }
      default:
        characters.moveNext();
        return parseCharacterRange(characterTree(startCharacter));
    }
  }

