  private SourceCharacter parseJavaEscapeSequence(SourceCharacter backslash) {
    unicodeProcessedCharacters.moveNext();
    SourceCharacter sourceCharacter = unicodeProcessedCharacters.getCurrent();
    if (sourceCharacter == null) {
      // Should only happen in case of syntactically invalid string literals
      return backslash;
    }
    char ch = sourceCharacter.getCharacter();
    switch (ch) {
      case 'n':
        ch = '\n';
        break;
      case 'r':
        ch = '\r';
        break;
      case 'f':
        ch = '\f';
        break;
      case 'b':
        ch = '\b';
        break;
      case 't':
        ch = '\t';
        break;
      default:
        if (isOctalDigit(ch)) {
          ch = 0;
          for (int i = 0; i < 3 && sourceCharacter != null && isOctalDigit(sourceCharacter.getCharacter()); i++) {
            int newValue = ch * 8 + sourceCharacter.getCharacter() - '0';
            if (newValue > 0xFF) {
              break;
            }
            ch = (char) newValue;
            unicodeProcessedCharacters.moveNext();
            sourceCharacter = unicodeProcessedCharacters.getCurrent();
          }
          int endIndex = sourceCharacter == null ? source.length() : sourceCharacter.getRange().getBeginningOffset();
          return new SourceCharacter(source, backslash.getRange().extendTo(endIndex), ch, true);
        }
        break;
    }
    unicodeProcessedCharacters.moveNext();
    return new SourceCharacter(source, backslash.getRange().merge(sourceCharacter.getRange()), ch, true);
  }

