  @VisibleForTesting
  ProgramState branchingState(Instruction terminator, ProgramState programState) {
    ProgramState.Pop pop;
    ProgramState ps;
    List<ProgramState.SymbolicValueSymbol> symbolicValueSymbols;
    switch (terminator.opcode) {
      case IFEQ:
      case IFNE:
      case IFLT:
      case IFGE:
      case IFGT:
      case IFLE:
        pop = programState.unstackValue(1);
        SymbolicValue svZero = new SymbolicValue();
        symbolicValueSymbols = ImmutableList.of(
            new ProgramState.SymbolicValueSymbol(svZero, null),
            pop.valuesAndSymbols.get(0));
        List<ProgramState> programStates = svZero.setConstraint(pop.state, DivisionByZeroCheck.ZeroConstraint.ZERO).stream()
            .flatMap(s -> svZero.setConstraint(s, BooleanConstraint.FALSE).stream()).collect(Collectors.toList());
        Preconditions.checkState(programStates.size() == 1);
        ps = programStates.get(0);
        break;
      case IF_ICMPEQ:
      case IF_ICMPNE:
      case IF_ICMPLT:
      case IF_ICMPGE:
      case IF_ICMPGT:
      case IF_ICMPLE:
      case IF_ACMPEQ:
      case IF_ACMPNE:
        pop = programState.unstackValue(2);
        symbolicValueSymbols = pop.valuesAndSymbols;
        ps = pop.state;
        break;
      case IFNULL:
      case IFNONNULL:
        pop = programState.unstackValue(1);
        symbolicValueSymbols = ImmutableList.of(
            new ProgramState.SymbolicValueSymbol(SymbolicValue.NULL_LITERAL, null),
            pop.valuesAndSymbols.get(0));
        ps = pop.state;
        break;
      default:
        throw new IllegalStateException("Unexpected terminator " + terminator);
    }
    return ps.stackValue(constraintManager.createBinarySymbolicValue(terminator, symbolicValueSymbols));
  }

