  @VisibleForTesting
  void executeInstruction(BytecodeCFGBuilder.Instruction instruction) {
    if(!checkerDispatcher.executeCheckPreStatement(instruction)) {
      return;
    }
    ProgramState.Pop pop;
    switch (instruction.opcode) {
      case ICONST_0:
        SymbolicValue svZero = constraintManager.createSymbolicValue(instruction);
        programState = programState.stackValue(svZero).addConstraint(svZero, DivisionByZeroCheck.ZeroConstraint.ZERO).addConstraint(svZero, BooleanConstraint.FALSE);
        break;
      case ICONST_M1:
      case ICONST_1:
      case ICONST_2:
      case ICONST_3:
      case ICONST_4:
      case ICONST_5:
        SymbolicValue svNonZero = constraintManager.createSymbolicValue(instruction);
        programState = programState.stackValue(svNonZero).addConstraint(svNonZero, DivisionByZeroCheck.ZeroConstraint.NON_ZERO);
        if (instruction.opcode == ICONST_1) {
          programState = programState.addConstraint(svNonZero, BooleanConstraint.TRUE);
        }
        break;
      case Opcodes.ARETURN:
      case Opcodes.IRETURN:
        programState.storeExitValue();
        break;
      case Opcodes.ATHROW:
        pop = programState.unstackValue(1);
        programState = pop.state.stackValue(constraintManager.createExceptionalSymbolicValue(null));
        programState.storeExitValue();
        break;
      case Opcodes.ACONST_NULL:
        programState = programState.stackValue(SymbolicValue.NULL_LITERAL);
        break;
      case Opcodes.ALOAD:
      case Opcodes.DLOAD:
      case Opcodes.FLOAD:
      case Opcodes.ILOAD:
      case Opcodes.LLOAD:
        SymbolicValue value = programState.getValue(instruction.operand);
        Preconditions.checkNotNull(value, "Loading a symbolic value unindexed");
        programState = programState.stackValue(value);
        break;
      case Opcodes.AALOAD:
        break;
      case Opcodes.BALOAD:
      case Opcodes.CALOAD:
      case Opcodes.DALOAD:
      case Opcodes.FALOAD:
      case Opcodes.IALOAD:
      case Opcodes.LALOAD:
      case Opcodes.SALOAD:
        break;
      case Opcodes.ASTORE:
      case Opcodes.DSTORE:
      case Opcodes.FSTORE:
      case Opcodes.ISTORE:
      case Opcodes.LSTORE:
        pop = programState.unstackValue(1);
        programState = pop.state.put(instruction.operand, pop.values.get(0));
        break;
      case Opcodes.LDC:
      case Opcodes.NEW: {
        SymbolicValue symbolicValue = constraintManager.createSymbolicValue(instruction);
        programState = programState.stackValue(symbolicValue);
        programState = programState.addConstraint(symbolicValue, ObjectConstraint.NOT_NULL);
        break;
      }
      case Opcodes.DUP: {
        SymbolicValue symbolicValue = programState.peekValue();
        Preconditions.checkNotNull(symbolicValue, "DUP on empty stack");
        programState = programState.stackValue(symbolicValue);
        break;
      }
      case Opcodes.INVOKESPECIAL:
      case Opcodes.INVOKESTATIC:
      case Opcodes.INVOKEVIRTUAL:
      case Opcodes.INVOKEINTERFACE:
        boolean isStatic = instruction.opcode == Opcodes.INVOKESTATIC;
        int arity = isStatic ? instruction.arity() : (instruction.arity() + 1);
        pop = programState.unstackValue(arity);
        Preconditions.checkState(pop.values.size() == arity, "Arguments mismatch for INVOKE");
        // TODO use constraintManager.createMethodSymbolicValue to create relational SV for equals
        SymbolicValue returnSV = constraintManager.createSymbolicValue(instruction);
        if (isStatic) {
          // follow only static invocations for now.
          String signature = instruction.fieldOrMethod.completeSignature();
          MethodBehavior methodInvokedBehavior = behaviorCache.get(signature);
          if (methodInvokedBehavior != null && methodInvokedBehavior.isComplete()) {
            methodInvokedBehavior
              .happyPathYields()
              .forEach(yield ->
                yield.statesAfterInvocation(Lists.reverse(pop.values), Collections.emptyList(), pop.state, () -> returnSV).forEach(ps -> {
                  checkerDispatcher.methodYield = yield;
                  checkerDispatcher.addTransition(ps);
                  checkerDispatcher.methodYield = null;
                }));
            methodInvokedBehavior
              .exceptionalPathYields()
              .forEach(yield ->
                yield.statesAfterInvocation(
                  Lists.reverse(pop.values), Collections.emptyList(), pop.state, () -> constraintManager.createExceptionalSymbolicValue(yield.exceptionType())).forEach(ps -> {
                  ps.storeExitValue();
                  enqueue(new ProgramPoint(exitBlock), ps);
                }));
            return;
          }

        }
        if (instruction.hasReturnValue()) {
          programState = pop.state;
        } else {
          programState = pop.state.stackValue(returnSV);
        }
        break;
      default:
        // do nothing
    }
    checkerDispatcher.executeCheckPostStatement(instruction);
  }

