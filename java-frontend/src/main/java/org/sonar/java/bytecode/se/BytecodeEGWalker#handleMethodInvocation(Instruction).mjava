  private boolean handleMethodInvocation(Instruction instruction) {
    boolean isStatic = instruction.opcode == Opcodes.INVOKESTATIC;
    int arity = isStatic ? instruction.arity() : (instruction.arity() + 1);
    ProgramState.Pop pop = programState.unstackValue(arity);
    Preconditions.checkState(pop.values.size() == arity, "Arguments mismatch for INVOKE");
    // TODO use constraintManager.createMethodSymbolicValue to create relational SV for equals
    SymbolicValue returnSV = constraintManager.createSymbolicValue(instruction);
    String signature = instruction.fieldOrMethod.completeSignature();
    MethodBehavior methodInvokedBehavior = behaviorCache.get(signature);
    if (methodInvokedBehavior != null && methodInvokedBehavior.isComplete()) {
      List<SymbolicValue> stack = Lists.reverse(pop.values);
      if (!isStatic) {
        // remove "thisSV" from stack before trying to apply any yield, as it should not match with arguments
        stack = stack.subList(1, stack.size());
      }
      List<SymbolicValue> arguments = stack;

      methodInvokedBehavior
        .happyPathYields()
        .forEach(yield -> yield.statesAfterInvocation(arguments, Collections.emptyList(), pop.state, () -> returnSV).forEach(ps -> {
          checkerDispatcher.methodYield = yield;
          checkerDispatcher.addTransition(ps);
          checkerDispatcher.methodYield = null;
        }));
      methodInvokedBehavior
        .exceptionalPathYields()
        .forEach(yield -> {
          org.sonar.plugins.java.api.semantic.Type exceptionType = yield.exceptionType();
          yield.statesAfterInvocation(
            arguments, Collections.emptyList(), pop.state, () -> constraintManager.createExceptionalSymbolicValue(exceptionType)).forEach(ps -> {
              ps.storeExitValue();
              enqueueExceptionHandlers(exceptionType, ps);
          });
        });
      // FIXME : empty yields here should not happen, for now act as if behavior was not resolved.
      return !methodInvokedBehavior.yields().isEmpty();
    }
    programState = pop.state;
    if (instruction.hasReturnValue()) {
      programState = programState.stackValue(returnSV);
      programState = setDoubleOrLong(returnSV, instruction.isLongOrDoubleValue());
    }
    return false;
  }

