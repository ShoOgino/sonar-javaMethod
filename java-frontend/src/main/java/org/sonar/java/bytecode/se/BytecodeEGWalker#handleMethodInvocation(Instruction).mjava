  private boolean handleMethodInvocation(Instruction instruction) {
    boolean isStatic = instruction.opcode == Opcodes.INVOKESTATIC;
    int arity = isStatic ? instruction.arity() : (instruction.arity() + 1);
    ProgramState.Pop pop = programState.unstackValue(arity);
    Preconditions.checkState(pop.values.size() == arity, "Arguments mismatch for INVOKE");
    // TODO use constraintManager.createMethodSymbolicValue to create relational SV for equals
    programState = pop.state;
    SymbolicValue returnSV = instruction.hasReturnValue() ? constraintManager.createSymbolicValue(instruction) : null;
    String signature = instruction.fieldOrMethod.completeSignature();
    MethodBehavior methodInvokedBehavior = behaviorCache.get(signature);
    enqueueUncheckedExceptions();
    // FIXME : empty yields here should not happen, for now act as if behavior was not resolved.
    if (methodInvokedBehavior != null && methodInvokedBehavior.isComplete() && !methodInvokedBehavior.yields().isEmpty()) {
      List<SymbolicValue> stack = Lists.reverse(pop.values);
      if (!isStatic) {
        // remove "thisSV" from stack before trying to apply any yield, as it should not match with arguments
        stack = stack.subList(1, stack.size());
      }
      List<SymbolicValue> arguments = stack;

      methodInvokedBehavior
        .happyPathYields()
        .forEach(yield -> yield.statesAfterInvocation(arguments, Collections.emptyList(), programState, () -> returnSV).forEach(ps -> {
          checkerDispatcher.methodYield = yield;
          checkerDispatcher.addTransition(ps);
          checkerDispatcher.methodYield = null;
        }));
      methodInvokedBehavior
        .exceptionalPathYields()
        .forEach(yield -> {
          Type exceptionType = yield.exceptionType(semanticModel);
          yield.statesAfterInvocation(
            arguments, Collections.emptyList(), programState, () -> constraintManager.createExceptionalSymbolicValue(exceptionType)).forEach(ps -> {
              ps.storeExitValue();
              enqueueExceptionHandlers(exceptionType, ps);
          });
        });
      return true;
    }
    if (methodInvokedBehavior != null) {
      methodInvokedBehavior.getDeclaredExceptions().forEach(exception -> {
        Type exceptionType = semanticModel.getClassType(exception);
        ProgramState ps = programState.stackValue(constraintManager.createExceptionalSymbolicValue(exceptionType));
        enqueueExceptionHandlers(exceptionType, ps);
      });
    }
    if (instruction.hasReturnValue()) {
      programState = programState.stackValue(returnSV);
      programState = setDoubleOrLong(returnSV, instruction.isLongOrDoubleValue());
    }
    return false;
  }

