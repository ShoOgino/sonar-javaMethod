  private boolean handleMethodInvocation(Instruction instruction) {
    boolean isStatic = instruction.opcode == Opcodes.INVOKESTATIC;
    int arity = isStatic ? instruction.arity() : (instruction.arity() + 1);
    ProgramState.Pop pop = programState.unstackValue(arity);
    Preconditions.checkState(pop.values.size() == arity, "Arguments mismatch for INVOKE");
    // TODO use constraintManager.createMethodSymbolicValue to create relational SV for equals
    SymbolicValue returnSV = constraintManager.createSymbolicValue(instruction);
    if (isStatic) {
      // follow only static invocations for now.
      String signature = instruction.fieldOrMethod.completeSignature();
      MethodBehavior methodInvokedBehavior = behaviorCache.get(signature);
      if (methodInvokedBehavior != null && methodInvokedBehavior.isComplete()) {
        methodInvokedBehavior
          .happyPathYields()
          .forEach(yield ->
            yield.statesAfterInvocation(Lists.reverse(pop.values), Collections.emptyList(), pop.state, () -> returnSV).forEach(ps -> {
              checkerDispatcher.methodYield = yield;
              checkerDispatcher.addTransition(ps);
              checkerDispatcher.methodYield = null;
            }));
        methodInvokedBehavior
          .exceptionalPathYields()
          .forEach(yield ->
            yield.statesAfterInvocation(
              Lists.reverse(pop.values), Collections.emptyList(), pop.state, () -> constraintManager.createExceptionalSymbolicValue(yield.exceptionType())).forEach(ps -> {
              ps.storeExitValue();
              enqueue(new ProgramPoint(exitBlock), ps);
            }));
        return true;
      }
    }
    programState = pop.state;
    if (instruction.hasReturnValue()) {
      programState = programState.stackValue(returnSV);
    }
    return false;
  }

