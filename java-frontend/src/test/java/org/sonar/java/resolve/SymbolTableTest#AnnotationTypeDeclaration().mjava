  @Test
  public void AnnotationTypeDeclaration() {
    Result result = Result.createFor("declarations/AnnotationTypeDeclaration");

    JavaSymbol.TypeJavaSymbol annotationSymbol = (JavaSymbol.TypeJavaSymbol) result.symbol("Declaration");
    assertThat(annotationSymbol.owner()).isSameAs(result.symbol("AnnotationTypeDeclaration"));
    assertThat(annotationSymbol.flags()).isEqualTo(Flags.PRIVATE | Flags.INTERFACE | Flags.ANNOTATION);
    assertThat(annotationSymbol.getSuperclass()).isNull(); // TODO should it be java.lang.Object?

    JavaSymbol superinterface = Iterables.getOnlyElement(annotationSymbol.getInterfaces()).symbol;
    assertThat(superinterface.getName()).isEqualTo("Annotation");
    assertThat(superinterface.owner).isInstanceOf(JavaSymbol.PackageJavaSymbol.class);
    assertThat(superinterface.owner.getName()).isEqualTo("java.lang.annotation");

    assertThat(annotationSymbol.members.lookup("this")).isEmpty();
    assertThat(((JavaSymbol.MethodJavaSymbol) annotationSymbol.members.lookup("value").get(0)).defaultValue()).isEqualTo(42);

    JavaSymbol.VariableJavaSymbol variableSymbol = (JavaSymbol.VariableJavaSymbol) result.symbol("FIRST_CONSTANT");
    assertThat(variableSymbol.owner()).isSameAs(annotationSymbol);
    assertThat(variableSymbol.flags()).isEqualTo(Flags.PUBLIC | Flags.STATIC | Flags.FINAL);

    variableSymbol = (JavaSymbol.VariableJavaSymbol) result.symbol("SECOND_CONSTANT");
    assertThat(variableSymbol.owner()).isSameAs(annotationSymbol);
    assertThat(variableSymbol.flags()).isEqualTo(Flags.PUBLIC | Flags.STATIC | Flags.FINAL);

    JavaSymbol.MethodJavaSymbol methodSymbol = (JavaSymbol.MethodJavaSymbol) result.symbol("value", 15);
    assertThat(methodSymbol.owner()).isSameAs(annotationSymbol);
    assertThat(methodSymbol.flags()).isEqualTo(Flags.PUBLIC | Flags.ABSTRACT);

    JavaSymbol.TypeJavaSymbol typeSymbol = (JavaSymbol.TypeJavaSymbol) result.symbol("NestedClass");
    assertThat(typeSymbol.owner()).isSameAs(annotationSymbol);
    assertThat(typeSymbol.flags()).isEqualTo(Flags.PUBLIC | Flags.STATIC);

    typeSymbol = (JavaSymbol.TypeJavaSymbol) result.symbol("NestedInterface");
    assertThat(typeSymbol.owner()).isSameAs(annotationSymbol);
    assertThat(typeSymbol.flags()).isEqualTo(Flags.PUBLIC | Flags.STATIC | Flags.INTERFACE);

    typeSymbol = (JavaSymbol.TypeJavaSymbol) result.symbol("NestedEnum");
    assertThat(typeSymbol.owner()).isSameAs(annotationSymbol);
    assertThat(typeSymbol.flags()).isEqualTo(Flags.PUBLIC | Flags.ENUM | Flags.STATIC);

    typeSymbol = (JavaSymbol.TypeJavaSymbol) result.symbol("NestedAnnotationType");
    assertThat(typeSymbol.owner()).isSameAs(annotationSymbol);
    assertThat(typeSymbol.flags()).isEqualTo(Flags.PUBLIC | Flags.STATIC | Flags.INTERFACE | Flags.ANNOTATION);

    Map<String, Object> nameToDefaultValue = new HashMap<>();
    List<JavaSymbol.MethodJavaSymbol> methodJavaSymbols = typeSymbol.memberSymbols()
      .stream()
      .filter(Symbol::isMethodSymbol)
      .map(s -> (JavaSymbol.MethodJavaSymbol) s)
      .collect(Collectors.toList());
    for (JavaSymbol.MethodJavaSymbol methodJavaSymbol : methodJavaSymbols) {
      nameToDefaultValue.put(methodJavaSymbol.name(), methodJavaSymbol.defaultValue);
    }

    assertThat(nameToDefaultValue.get("valueString")).isEqualTo("valueDefault");
    assertThat(nameToDefaultValue.get("valueInt")).isEqualTo(42);
    assertThat(nameToDefaultValue.get("valueLong")).isEqualTo(42L);
    // constants are unsupported when read from sources
    assertThat(nameToDefaultValue.get("valueStringConstant")).isNull();
    // arrays not wrapped when read from sources
    assertThat(nameToDefaultValue.get("valueArray")).isEqualTo(0);
    assertThat(nameToDefaultValue.get("noDefault")).isNull();
    // unsupported
    assertThat(nameToDefaultValue.get("valueEnum")).isNull();
  }

