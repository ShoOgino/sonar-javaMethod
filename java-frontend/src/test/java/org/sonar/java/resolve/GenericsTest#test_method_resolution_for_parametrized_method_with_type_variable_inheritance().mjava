  @Test
  public void test_method_resolution_for_parametrized_method_with_type_variable_inheritance() {
    List<Type> elementTypes = declaredTypes(
      "class Test<T> {"
        + "  <S extends T> void foo(S s) {}"

        + "  void test() {"
        // type substitution provided
        + "    new Test<A>().<A>foo(new A());"
        + "    new Test<A>().<B>foo(new B());"
        // type inference
        + "    new Test<A>().foo(new A());"
        + "    new Test<A>().foo(new B());"
        + "  }"
        + "}"
        + "class A {}"
        + "class B extends A {}");

    JavaType type = (JavaType) elementTypes.get(0);
    JavaSymbol.MethodJavaSymbol methodSymbol = getMethodSymbol(type, "foo");
    assertThat(methodSymbol.usages()).hasSize(4);

    elementTypes = declaredTypes(
      "class Test<T> {"
        + "  <S extends T> void foo(S s) {}"

        + "  void test() {"
        // does not compile - not resolved
        + " new Test<B>().foo(new A());"
        + " new Test<B>().<A>foo(new A());"
        + "  }"
        + "}"
        + "class A {}"
        + "class B extends A {}");

    type = (JavaType) elementTypes.get(0);
    methodSymbol = getMethodSymbol(type, "foo");
    assertThat(methodSymbol.usages()).hasSize(0);
  }

