  @Test
  public void type_hierarchy_visit_should_be_limited() {
    ParametrizedTypeCache parametrizedTypeCache = new ParametrizedTypeCache();
    BytecodeCompleter bytecodeCompleter = new BytecodeCompleter(new SquidClassLoader(new ArrayList<>()), parametrizedTypeCache);
    Symbols symbols = new Symbols(bytecodeCompleter);

    ActionParser<Tree> parser = JavaParser.createParser();
    SemanticModel semanticModel = new SemanticModel(bytecodeCompleter);
    Resolve resolve = new Resolve(symbols, bytecodeCompleter, parametrizedTypeCache);
    TypeAndReferenceSolver typeAndReferenceSolver = new TypeAndReferenceSolver(semanticModel, symbols, resolve, parametrizedTypeCache);
    CompilationUnitTree tree = (CompilationUnitTree) parser.parse(new File("src/test/files/sym/ComplexHierarchy.java"));
    new FirstPass(semanticModel, symbols, resolve, parametrizedTypeCache, typeAndReferenceSolver).visitCompilationUnit(tree);
    typeAndReferenceSolver.visitCompilationUnit(tree);

    ClassTree classTree = (ClassTree) tree.types().get(tree.types().size() - 1);
    JavaType site = (JavaType) classTree.symbol().type();
    MethodInvocationTree mit = (MethodInvocationTree) ((ExpressionStatementTree) ((MethodTree) classTree.members().get(0)).block().body().get(0)).expression();

    TypeSubstitutionSolver typeSubstitutionSolver = Mockito.spy(new TypeSubstitutionSolver(parametrizedTypeCache, symbols));
    // call with empty formals should return.
    typeSubstitutionSolver.applySiteSubstitutionToFormalParameters(new ArrayList<>(), site);
    verify(typeSubstitutionSolver, times(0)).applySiteSubstitutionToFormalParameters(anyList(), any(JavaType.class), anySet());

    JavaSymbol.MethodJavaSymbol methodJavaSymbol = (JavaSymbol.MethodJavaSymbol) mit.symbol();
    typeSubstitutionSolver.applySiteSubstitutionToFormalParameters(((MethodJavaType) methodJavaSymbol.type).argTypes, site);
    verify(typeSubstitutionSolver, times(11)).applySiteSubstitutionToFormalParameters(anyList(), any(JavaType.class), anySet());
  }

