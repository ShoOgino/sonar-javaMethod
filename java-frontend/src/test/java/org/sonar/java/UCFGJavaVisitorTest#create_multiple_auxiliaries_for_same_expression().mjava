  @Test
  public void create_multiple_auxiliaries_for_same_expression() {
    Expression.Variable arg = variableWithId("arg");
    Expression.Variable aux0 = variableWithId("%0");
    Expression.Variable aux1 = variableWithId("%1");
    Expression.Variable aux2 = variableWithId("%2");
    Expression.Variable aux3 = variableWithId("%3");
    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#foo(Ljava/lang/String;)Ljava/lang/String;").addMethodParam(arg)
        .addBasicBlock(newBasicBlock("1")
            .assignTo(aux0, call("java.lang.Object#toString()Ljava/lang/String;").withArgs(Expression.THIS), new LocationInFile(FILE_KEY, 3, 4, 3, 19))
            .assignTo(aux1, call("java.lang.Object#toString()Ljava/lang/String;").withArgs(Expression.THIS), new LocationInFile(FILE_KEY, 4, 4, 4, 19))
            .assignTo(aux2, call("__concat").withArgs(constant("\"\""), arg), new LocationInFile(FILE_KEY, 5,15,5,25))
            .assignTo(aux3, call("__concat").withArgs(constant("\"\""), arg), new LocationInFile(FILE_KEY, 6,15,6,25))
            .ret(constant(""), new LocationInFile(FILE_KEY, 7, 4, 7, 14)))
        .build();
    assertCodeToUCfg("class A { \n" +
        "  private String foo(String arg) { \n" +
        "    this.toString();\n" +
        "    this.toString();\n" +
        "    String x = true + arg;\n" +
        "    String y = true + arg;\n" +
        "    return \"\";\n" +
        "  }\n" +
        "}", expectedUCFG);
  }

