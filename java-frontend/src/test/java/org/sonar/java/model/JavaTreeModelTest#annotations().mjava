  @Test
  void annotations() {
    ClassTree tree = firstType("@SuppressWarnings(\"unchecked\") class T { }");
    List<AnnotationTree> annotations = tree.modifiers().annotations();
    assertThat(annotations).hasSize(1);
    AnnotationTree annotation = annotations.get(0);
    assertThat(annotation.annotationType().is(Tree.Kind.IDENTIFIER)).isTrue();
    assertThat(annotation.arguments().openParenToken()).isNotNull();
    assertThat(annotation.arguments().separators()).isEmpty();
    assertThat(annotation.arguments()).hasSize(1);
    assertThat(annotation.arguments().get(0).is(Tree.Kind.STRING_LITERAL)).isTrue();
    assertThat(annotation.arguments().closeParenToken()).isNotNull();
    assertThat(annotation.atToken()).isNotNull();
    assertThatChildrenIteratorHasSize(annotation, 3);

    tree = firstType("@Target( ) class U {}");
    annotations = tree.modifiers().annotations();
    assertThat(annotations).hasSize(1);
    annotation = annotations.get(0);
    assertThat(annotation.arguments().openParenToken()).isNotNull();
    assertThat(annotation.arguments()).isEmpty();
    assertThat(annotation.arguments().separators()).isEmpty();
    assertThat(annotation.arguments().closeParenToken()).isNotNull();
    assertThat(annotation.atToken()).isNotNull();
    assertThatChildrenIteratorHasSize(annotation, 3);

    tree = firstType("@Target({ElementType.METHOD}) class U {}");
    annotations = tree.modifiers().annotations();
    assertThat(annotations).hasSize(1);
    annotation = annotations.get(0);
    assertThat(annotation.arguments().openParenToken()).isNotNull();
    assertThat(annotation.arguments()).hasSize(1);
    assertThat(annotation.arguments().get(0).is(Tree.Kind.NEW_ARRAY)).isTrue();
    assertThat(annotation.arguments().separators()).isEmpty();
    assertThat(annotation.arguments().closeParenToken()).isNotNull();
    assertThat(annotation.atToken()).isNotNull();
    assertThatChildrenIteratorHasSize(annotation, 3);

    tree = firstType("@SuppressWarnings({\"hello\",}) class U {}");
    annotations = tree.modifiers().annotations();
    assertThat(annotations).hasSize(1);
    annotation = annotations.get(0);
    assertThat(annotation.arguments().openParenToken()).isNotNull();
    assertThat(annotation.arguments()).hasSize(1);
    assertThat(annotation.arguments().get(0).is(Tree.Kind.NEW_ARRAY)).isTrue();
    NewArrayTree arg = (NewArrayTree) annotation.arguments().get(0);
    assertThat(arg.initializers()).hasSize(1);
    assertThat(arg.initializers().get(0).is(Tree.Kind.STRING_LITERAL)).isTrue();
    assertThat(arg.initializers().separators()).hasSize(1);
    assertThat(annotation.arguments().closeParenToken()).isNotNull();
    assertThat(annotation.atToken()).isNotNull();
    assertThatChildrenIteratorHasSize(annotation, 3);

    tree = firstType("@Target(value={ElementType.METHOD}, value2=\"toto\") class T { }");
    annotations = tree.modifiers().annotations();
    assertThat(annotations).hasSize(1);
    annotation = annotations.get(0);
    assertThat(annotation.annotationType().is(Tree.Kind.IDENTIFIER)).isTrue();
    assertThat(annotation.arguments().openParenToken()).isNotNull();
    assertThat(annotation.arguments()).hasSize(2);
    assertThat(annotation.arguments().separators()).hasSize(1);
    assertThat(annotation.arguments().get(0).is(Tree.Kind.ASSIGNMENT)).isTrue();
    assertThat(annotation.arguments().closeParenToken()).isNotNull();
    assertThat(annotation.atToken()).isNotNull();
    assertThatChildrenIteratorHasSize(annotation, 3);

    VariableTree variable = (VariableTree) firstMethodFirstStatement("class T { private void meth() { @NonNullable String str;}}");
    assertThatChildrenIteratorHasSize(variable, 4);
    annotations = variable.modifiers().annotations();
    assertThat(annotations).hasSize(1);
    annotation = annotations.get(0);
    assertThat(annotation.annotationType().is(Tree.Kind.IDENTIFIER)).isTrue();
    assertThat(annotation.atToken()).isNotNull();
    assertThat(annotation.arguments()).isEmpty();
    assertThatChildrenIteratorHasSize(annotation, 3);

    annotations = JParserTestUtils.parsePackage("@PackageLevelAnnotation package blammy;").packageDeclaration().annotations();
    assertThat(annotations).hasSize(1);
    assertThat(annotations.get(0).atToken()).isNotNull();
    assertThat(annotation.arguments()).isEmpty();
    assertThatChildrenIteratorHasSize(annotation, 3);

    variable = (VariableTree) firstMethodFirstStatement("class T { private void m() { @Foo Integer foo; } }");
    assertThat(variable.modifiers().annotations()).hasSize(1);
    assertThat(variable.type().is(Tree.Kind.IDENTIFIER)).isTrue();
    assertThat(variable.type().annotations()).isEmpty();
    assertThatChildrenIteratorHasSize(variable, 4);

    variable = (VariableTree) firstMethodFirstStatement("class T { private void m() { @Foo java.lang.Integer foo; } }");
    assertThat(variable.modifiers().annotations()).hasSize(1);
    assertThat(variable.type().is(Tree.Kind.MEMBER_SELECT)).isTrue();
    assertThat(variable.type().annotations()).isEmpty();
    assertThatChildrenIteratorHasSize(variable, 4);

    variable = (VariableTree) firstMethodFirstStatement("class T { private void m() { java.lang.@Foo Integer foo; } }");
    assertThat(variable.modifiers()).isEmpty();
    assertThat(variable.type().is(Tree.Kind.MEMBER_SELECT)).isTrue();
    assertThat(variable.type().annotations()).isEmpty();
    assertThatChildrenIteratorHasSize(variable, 4);
    assertThat(((MemberSelectExpressionTree) variable.type()).identifier().annotations()).hasSize(1);

    variable = (VariableTree) firstMethodFirstStatement("class T { private void m() { a.B.C foo = a.B.new @Foo C(); } }");
    assertThat(variable.modifiers()).isEmpty();
    assertThatChildrenIteratorHasSize(variable, 6);
    TypeTree type = ((NewClassTree) variable.initializer()).identifier();
    assertThat(type.is(Tree.Kind.IDENTIFIER)).isTrue();
    assertThat(type.annotations()).hasSize(1);
    assertThatChildrenIteratorHasSize(type, 2);

    variable = (VariableTree) firstMethodFirstStatement("class T { private void m() { int[] foo = new @Foo int[42]; } }");
    assertThat(variable.modifiers()).isEmpty();
    assertThatChildrenIteratorHasSize(variable, 6);
    type = ((NewArrayTree) variable.initializer()).type();
    assertThat(type.is(Tree.Kind.PRIMITIVE_TYPE)).isTrue();
    assertThat(type.annotations()).hasSize(1);
    assertThatChildrenIteratorHasSize(type, 2);

    variable = ((TryStatementTree) firstMethodFirstStatement("class T { private void m() { try{ } catch (@Foo E1 | E2 e) {}; } }")).catches().get(0).parameter();
    assertThat(variable.modifiers()).hasSize(1);
    assertThatChildrenIteratorHasSize(variable, 3);
    type = variable.type();
    assertThat(type.is(Tree.Kind.UNION_TYPE)).isTrue();
    assertThat(type.annotations()).isEmpty();
    assertThat(((UnionTypeTree) type).typeAlternatives().separators()).hasSize(1);
    assertThatChildrenIteratorHasSize(type, 1);

    variable = (VariableTree) firstMethodFirstStatement("class T { private void m() { a.b.C<Integer> foo = a.B.new @Foo C<Integer>(); }}");
    assertThat(variable.modifiers()).isEmpty();
    assertThatChildrenIteratorHasSize(variable, 6);
    type = ((NewClassTree) variable.initializer()).identifier();
    assertThat(type.is(Tree.Kind.PARAMETERIZED_TYPE)).isTrue();
    assertThat(type.annotations()).isEmpty();
    assertThatChildrenIteratorHasSize(type, 2);
    type = ((ParameterizedTypeTree) type).type();
    assertThat(type.is(Tree.Kind.IDENTIFIER)).isTrue();
    assertThat(type.annotations()).hasSize(1);
    assertThatChildrenIteratorHasSize(type, 2);

    variable = (VariableTree) firstMethodFirstStatement("package a; class B { private void m() { a.B.C foo = new a.B. @Foo C(); } class C {}}");
    assertThat(variable.modifiers()).isEmpty();
    assertThatChildrenIteratorHasSize(variable, 6);
    type = ((NewClassTree) variable.initializer()).identifier();
    assertThat(type.is(Tree.Kind.MEMBER_SELECT)).isTrue();
    assertThat(type.annotations()).isEmpty();
    assertThatChildrenIteratorHasSize(type, 3);
    type = ((MemberSelectExpressionTree) type).identifier();
    assertThat(type.annotations()).hasSize(1);
    assertThatChildrenIteratorHasSize(type, 2);

    variable = (VariableTree) firstMethodFirstStatement("package a.b; class C<T> { private void m() { a.b.C<Integer> foo = new a.b. @Foo C<Integer>(); } }");
    assertThat(variable.modifiers()).isEmpty();
    assertThatChildrenIteratorHasSize(variable, 6);
    type = ((NewClassTree) variable.initializer()).identifier();
    assertThat(type.is(Tree.Kind.PARAMETERIZED_TYPE)).isTrue();
    assertThat(type.annotations()).isEmpty();
    assertThatChildrenIteratorHasSize(type, 2);
    type = ((ParameterizedTypeTree) type).type();
    assertThat(type.is(Tree.Kind.MEMBER_SELECT)).isTrue();
    assertThat(type.annotations()).isEmpty();
    assertThatChildrenIteratorHasSize(type, 3);
    type = ((MemberSelectExpressionTree) type).identifier();
    assertThat(type.annotations()).hasSize(1);
    assertThatChildrenIteratorHasSize(type, 2);

    ClassTree classTree = firstType("class T extends a.b.@Foo C {}");
    assertThat(classTree.modifiers()).isEmpty();
    assertThatChildrenIteratorHasSize(classTree, 9);
    type = classTree.superClass();
    assertThat(type.is(Tree.Kind.MEMBER_SELECT)).isTrue();
    assertThat(type.annotations()).isEmpty();
    assertThatChildrenIteratorHasSize(type, 3);
    type = ((MemberSelectExpressionTree) type).identifier();
    assertThat(type.annotations()).hasSize(1);
    assertThatChildrenIteratorHasSize(type, 2);

    classTree = firstType("class T extends a.b. @Foo C<Integer> {}");
    assertThat(classTree.modifiers()).isEmpty();
    assertThatChildrenIteratorHasSize(classTree, 9);
    type = classTree.superClass();
    assertThat(type.is(Tree.Kind.PARAMETERIZED_TYPE)).isTrue();
    assertThat(type.annotations()).isEmpty();
    assertThatChildrenIteratorHasSize(type, 2);
    type = ((ParameterizedTypeTree) type).type();
    assertThat(type.is(Tree.Kind.MEMBER_SELECT)).isTrue();
    assertThat(type.annotations()).isEmpty();
    assertThatChildrenIteratorHasSize(type, 3);
    type = ((MemberSelectExpressionTree) type).identifier();
    assertThat(type.annotations()).hasSize(1);
    assertThatChildrenIteratorHasSize(type, 2);

    classTree = (ClassTree) firstMethodFirstStatement("class MyClass<A, B, C> { void foo() { class MyOtherClass extends @Foo MyClass<A, B, C>.MyInnerClass {} } class MyInnerClass {}}");
    assertThat(classTree.modifiers()).isEmpty();
    assertThatChildrenIteratorHasSize(classTree, 9);
    type = classTree.superClass();
    assertThat(type.is(Tree.Kind.MEMBER_SELECT)).isTrue();
    assertThat(type.annotations()).isEmpty();
    type = (ParameterizedTypeTree) ((MemberSelectExpressionTree) type).expression();
    assertThat(type.is(Tree.Kind.PARAMETERIZED_TYPE)).isTrue();
    assertThat(type.annotations()).hasSize(0);
    assertThatChildrenIteratorHasSize(type, 2);
    type = ((ParameterizedTypeTree) type).type();
    assertThat(type.is(Tree.Kind.IDENTIFIER)).isTrue();
    assertThat(type.annotations()).hasSize(1);
    assertThatChildrenIteratorHasSize(type, 2);

    TypeCastTree typeCast = (TypeCastTree) ((ReturnStatementTree) firstMethodFirstStatement("class T { private long m(int a) { return (@Foo long) a; } }")).expression();
    assertThat(typeCast.type()).isNotNull();
    assertThatChildrenIteratorHasSize(typeCast, 5);
    type = typeCast.type();
    assertThat(type.is(Tree.Kind.PRIMITIVE_TYPE)).isTrue();
    assertThat(type.annotations()).hasSize(1);
    assertThatChildrenIteratorHasSize(type, 2);
  }

