  @Test
  public void isPublicApi() {
    new SubscriptionVisitor() {

      private Deque<ClassTree> classTrees = Lists.newLinkedList();
      private Deque<MethodTree> methodTrees = Lists.newLinkedList();

      @Override
      public List<Tree.Kind> nodesToVisit() {
        return Arrays.asList(Tree.Kind.values());
      }

      @Override
      public void visitNode(Tree tree) {
        if (tree.is(Tree.Kind.VARIABLE)) {
          VariableTree variableTree = (VariableTree) tree;
          String name = variableTree.simpleName().name();
          Tree parent = classTrees.peek();
          if(!methodTrees.isEmpty()) {
            parent = methodTrees.peek();
          }
          assertThat(publicApiChecker.isPublicApi(parent, tree)).as(name).isEqualTo(name.endsWith("Public"));
        } else if (tree.is(PublicApiChecker.METHOD_KINDS)) {
          MethodTree methodTree = (MethodTree) tree;
          methodTrees.push(methodTree);
          String name = methodTree.simpleName().name();
          assertThat(publicApiChecker.isPublicApi(classTrees.peek(), tree)).as(name).isEqualTo(name.endsWith("Public"));
        } else if (tree.is(PublicApiChecker.CLASS_KINDS)) {
          IdentifierTree className = ((ClassTree)tree).simpleName();
          assertThat(publicApiChecker.isPublicApi(classTrees.peek(), tree)).as(className.name()).isEqualTo(className != null && className.name().endsWith("Public"));
          classTrees.push((ClassTree) tree);
        } else {
          assertThat(publicApiChecker.isPublicApi(classTrees.peek(), tree)).isFalse();
        }
      }

      @Override
      public void leaveNode(Tree tree) {
        if (tree.is(PublicApiChecker.CLASS_KINDS)) {
          classTrees.pop();
        } else if(tree.is(PublicApiChecker.METHOD_KINDS)) {
          methodTrees.pop();
        }
      }
    }.scanTree(cut);
  }

