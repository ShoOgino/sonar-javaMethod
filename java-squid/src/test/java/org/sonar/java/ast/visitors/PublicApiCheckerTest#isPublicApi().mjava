  @Test
  public void isPublicApi() {
    new SubscriptionVisitor() {

      private Deque<ClassTree> classTrees = Lists.newLinkedList();

      @Override
      public List<Tree.Kind> nodesToVisit() {
        return Arrays.asList(Tree.Kind.values());
      }

      @Override
      public void visitNode(Tree tree) {
        if (tree.is(Tree.Kind.VARIABLE)) {
          VariableTree variableTree = (VariableTree) tree;
          String name = variableTree.simpleName().name();
          assertThat(publicApiChecker.isPublicApi(classTrees.peek(), tree)).as(name).isEqualTo(name.endsWith("Public"));
        } else if (tree.is(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR)) {
          MethodTree methodTree = (MethodTree) tree;
          String name = methodTree.simpleName().name();
          assertThat(publicApiChecker.isPublicApi(classTrees.peek(), tree)).as(name).isEqualTo(name.endsWith("Public"));
        } else if (tree.is(Tree.Kind.CLASS, Tree.Kind.ENUM, Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE)) {
          classTrees.push((ClassTree) tree);
          IdentifierTree className = classTrees.peek().simpleName();
          assertThat(publicApiChecker.isPublicApi(classTrees.peek(), tree)).isEqualTo(className != null && className.name().endsWith("Public"));
        } else {
          assertThat(publicApiChecker.isPublicApi(classTrees.peek(), tree)).isFalse();
        }
      }

      @Override
      public void leaveNode(Tree tree) {
        if (tree.is(Tree.Kind.CLASS, Tree.Kind.ENUM, Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE)) {
          classTrees.pop();
        }
      }
    }.scanTree(cut);
  }

