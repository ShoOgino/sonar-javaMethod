  /**
   * Simulates creation of symbols and types.
   */
  @Before
  public void setUp() {
    Symbol.PackageSymbol p = new Symbol.PackageSymbol(null, null);
    p.members = new Scope(p);

    // class MyClass
    classSymbol = new Symbol.TypeSymbol(0, "MyClass", p);
    classType = ((Type.ClassType) classSymbol.type);
    classType.supertype = symbols.unknownType; // TODO extend some superclass
    classType.interfaces = ImmutableList.of();
    classSymbol.members = new Scope(classSymbol);
    p.members.enter(classSymbol);

    // int[][] var;
    variableSymbol = new Symbol.VariableSymbol(0, "var", classSymbol);
    variableSymbol.type = new Type.ArrayType(new Type.ArrayType(symbols.intType, symbols.arrayClass), symbols.arrayClass);
    classSymbol.members.enter(variableSymbol);

    // MyClass var2;
    classSymbol.members.enter(new Symbol.VariableSymbol(0, "var2", classType, classSymbol));

    // int method()
    methodSymbol = new Symbol.MethodSymbol(0, "method", classSymbol);
    methodSymbol.type = new Type.MethodType(ImmutableList.<Type>of(), symbols.intType, ImmutableList.<Type>of(), /* TODO defining class? */ null);
    classSymbol.members.enter(methodSymbol);

    classSymbol.members.enter(new Symbol.VariableSymbol(0, "this", classType, classSymbol));
    classSymbol.members.enter(new Symbol.VariableSymbol(0, "super", classType.supertype, classSymbol));

    // FIXME figure out why top is mandatory
    Resolve.Env top = new Resolve.Env();

    Resolve.Env compilationUnitEnv = new Resolve.Env();
    compilationUnitEnv.outer = top;
    compilationUnitEnv.packge = p;
    compilationUnitEnv.scope = p.members;
    compilationUnitEnv.enclosingClass = symbols.predefClass;

    env = compilationUnitEnv.dup();
    env.outer = compilationUnitEnv;
    env.enclosingClass = classSymbol;
    env.scope = classSymbol.members;
  }

