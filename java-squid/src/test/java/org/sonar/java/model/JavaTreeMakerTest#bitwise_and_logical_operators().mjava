  /**
   * 15.22. Bitwise and Logical Operators
   */
  @Test
  public void bitwise_and_logical_operators() {
    BinaryExpressionTree tree = (BinaryExpressionTree) p.parse("class T { int m() { return 1 & 2 & 3; } }").getFirstDescendant(Kind.AND);
    assertThat(tree.is(Tree.Kind.AND)).isTrue();
    assertThat(tree.leftOperand()).isNotNull();
    assertThat(tree.operatorToken().text()).isEqualTo("&");
    assertThat(tree.rightOperand()).isNotNull();
    tree = (BinaryExpressionTree) tree.rightOperand();
    assertThat(tree.is(Tree.Kind.AND)).isTrue();
    assertThat(tree.leftOperand()).isNotNull();
    assertThat(tree.operatorToken().text()).isEqualTo("&");
    assertThat(tree.rightOperand()).isNotNull();

    tree = (BinaryExpressionTree) p.parse("class T { int m() { return 1 ^ 2 ^ 3; } }").getFirstDescendant(Kind.XOR);
    assertThat(tree.is(Tree.Kind.XOR)).isTrue();
    assertThat(tree.leftOperand()).isNotNull();
    assertThat(tree.operatorToken().text()).isEqualTo("^");
    assertThat(tree.rightOperand()).isNotNull();
    tree = (BinaryExpressionTree) tree.rightOperand();
    assertThat(tree.is(Tree.Kind.XOR)).isTrue();
    assertThat(tree.leftOperand()).isNotNull();
    assertThat(tree.operatorToken().text()).isEqualTo("^");
    assertThat(tree.rightOperand()).isNotNull();

    AstNode astNode = p.parse("class T { int m() { return 1 | 2 | 3; } }").getFirstDescendant(JavaGrammar.INCLUSIVE_OR_EXPRESSION);
    tree = (BinaryExpressionTree) maker.expression(astNode);
    assertThat(tree.is(Tree.Kind.OR)).isTrue();
    assertThat(tree.leftOperand()).isNotNull();
    assertThat(tree.operatorToken().text()).isEqualTo("|");
    assertThat(tree.rightOperand()).isNotNull();
    tree = (BinaryExpressionTree) tree.rightOperand();
    assertThat(tree.is(Tree.Kind.OR)).isTrue();
    assertThat(tree.leftOperand()).isNotNull();
    assertThat(tree.operatorToken().text()).isEqualTo("|");
    assertThat(tree.rightOperand()).isNotNull();
  }

