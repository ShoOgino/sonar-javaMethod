  private MethodTree methodDeclarator(ModifiersTree modifiers, List<TypeParameterTree> typeParameters, @Nullable AstNode returnTypeNode, AstNode name, AstNode astNode) {
    checkType(name, JavaTokenType.IDENTIFIER);
    checkType(astNode, JavaGrammar.METHOD_DECLARATOR_REST,
      JavaGrammar.VOID_METHOD_DECLARATOR_REST,
      JavaGrammar.CONSTRUCTOR_DECLARATOR_REST,
      JavaGrammar.VOID_INTERFACE_METHOD_DECLARATORS_REST,
      JavaGrammar.INTERFACE_METHOD_DECLARATOR_REST);

    Tree returnType = null;
    if (returnTypeNode != null) {
      if (returnTypeNode.is(JavaKeyword.VOID)) {
        returnType = basicType(returnTypeNode);
      } else {
        returnType = applyDim((ExpressionTree) returnTypeNode, astNode.getChildren(JavaGrammar.DIM).size());
      }
    }
    BlockTree body = null;
    if (astNode.hasDirectChildren(JavaGrammar.METHOD_BODY)) {
      body = (BlockTree) astNode.getFirstChild(JavaGrammar.METHOD_BODY).getFirstChild(Kind.BLOCK);
    }
    QualifiedIdentifierListTreeImpl throwsClauseNode = (QualifiedIdentifierListTreeImpl) astNode.getFirstChild(JavaGrammar.QUALIFIED_IDENTIFIER_LIST);
    return new MethodTreeImpl(
      astNode,
      modifiers,
      typeParameters,
      returnType,
      identifier(name),
      (List) astNode.getFirstChild(JavaGrammar.FORMAL_PARAMETERS),
      body,
      throwsClauseNode != null ? throwsClauseNode : ImmutableList.<ExpressionTree>of(),
      null);
  }

