  public CompilationUnitTreeImpl newCompilationUnit(
    AstNode spacing,
    Optional<ExpressionTree> packageDeclaration,
    Optional<List<ImportClauseTree>> importDeclarations,
    Optional<List<AstNode>> typeDeclarations,
    AstNode eof) {

    List<AstNode> children = Lists.newArrayList();
    children.add(spacing);

    ImmutableList.Builder<AnnotationTree> packageAnnotations = ImmutableList.builder();
    if (packageDeclaration.isPresent()) {
      children.add((AstNode) packageDeclaration.get());
      for (AstNode child : ((AstNode) packageDeclaration.get()).getChildren()) {
        if (child.is(Kind.ANNOTATION)) {
          packageAnnotations.add((AnnotationTree) child);
        }
      }
    }

    ImmutableList.Builder<ImportClauseTree> imports = ImmutableList.builder();
    if (importDeclarations.isPresent()) {
      for (ImportClauseTree child : importDeclarations.get()) {
        children.add((AstNode) child);

        if (!child.is(Kind.EMPTY_STATEMENT)) {
          imports.add((ImportTreeImpl) child);
        } else {
          imports.add((EmptyStatementTreeImpl) child);
        }
      }
    }

    ImmutableList.Builder<Tree> types = ImmutableList.builder();
    if (typeDeclarations.isPresent()) {
      children.addAll(typeDeclarations.get());

      for (AstNode child : typeDeclarations.get()) {
        if (!child.is(JavaPunctuator.SEMI)) {
          types.add((Tree) child);
        }
      }
    }

    children.add(eof);

    return new CompilationUnitTreeImpl(
      packageDeclaration.orNull(),
      imports.build(),
      types.build(),
      packageAnnotations.build(),
      children);
  }

