  public CompilationUnitTreeImpl newCompilationUnit(
    AstNode spacing,
    Optional<PackageDeclarationTree> packageDeclaration,
    Optional<List<ImportClauseTree>> importDeclarations,
    Optional<List<Tree>> typeDeclarations,
    AstNode eof) {

    List<AstNode> children = Lists.newArrayList();
    children.add(spacing);

    if (packageDeclaration.isPresent()) {
      children.add((AstNode) packageDeclaration.get());
    }

    ImmutableList.Builder<ImportClauseTree> imports = ImmutableList.builder();
    if (importDeclarations.isPresent()) {
      for (ImportClauseTree child : importDeclarations.get()) {
        children.add((AstNode) child);

        if (!child.is(Kind.EMPTY_STATEMENT)) {
          imports.add((ImportTreeImpl) child);
        } else {
          imports.add((EmptyStatementTreeImpl) child);
        }
      }
    }

    ImmutableList.Builder<Tree> types = ImmutableList.builder();
    if (typeDeclarations.isPresent()) {
      for (Tree child : typeDeclarations.get()) {
        children.add((AstNode) child);
        types.add(child);
      }
    }

    InternalSyntaxToken eofToken = InternalSyntaxToken.create(eof);
    children.add(eofToken);

    return new CompilationUnitTreeImpl(
      packageDeclaration.orNull(),
      imports.build(),
      types.build(),
      eofToken,
      children);
  }

