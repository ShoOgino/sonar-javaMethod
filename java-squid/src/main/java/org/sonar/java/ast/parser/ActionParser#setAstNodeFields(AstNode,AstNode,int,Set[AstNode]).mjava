  private void setAstNodeFields(AstNode astNode, @Nullable AstNode parent, int childIndex, Set<AstNode> ancestors) {
    if (verifyAssertions && parent != null) {
      if (AstNodeHacks.getChildIndex(astNode) != childIndex) {
        throw new IllegalArgumentException("Bad childIndex on node: " + nodeToString(astNode) + ": " + astNode
          + "\nExpected: " + childIndex
          + "\nActual: " + AstNodeHacks.getChildIndex(astNode)
          + "\nParent:"
          + "\n" + AstXmlPrinter.print(parent));
      }
    }
    AstNodeHacks.setParent(astNode, parent);

    List<AstNode> children = astNode.getChildren();
    if (!children.isEmpty()) {
      Token token = null;
      int fromIndex = -1;
      int toIndex = -1;

      if (verifyAssertions) {
        ancestors.add(astNode);
      }
      for (int i = 0; i < children.size(); i++) {
        AstNode child = children.get(i);
        Preconditions.checkState(!ancestors.contains(child), "Cycle in AstNode on node: " + child);
        setAstNodeFields(child, astNode, i, ancestors);

        if (token == null && child.hasToken()) {
          token = child.getToken();
        }

        if (fromIndex == -1) {
          fromIndex = child.getFromIndex();
        }

        if (!child.hasToken()) {
          child.setFromIndex(toIndex);
          child.setToIndex(toIndex);
        }

        toIndex = child.getToIndex();
      }
      if (verifyAssertions) {
        ancestors.remove(astNode);
      }

      AstNodeHacks.setToken(astNode, token);
      astNode.setFromIndex(fromIndex);
      astNode.setToIndex(toIndex);
    }
  }

