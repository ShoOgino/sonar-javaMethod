  public ClassTreeImpl newEnumDeclaration(
    AstNode enumTokenAstNode,
    AstNode identifierAstNode,
    Optional<Tuple<AstNode, QualifiedIdentifierListTreeImpl>> implementsClause,
    AstNode openBraceTokenAstNode,
    Optional<List<EnumConstantTreeImpl>> enumConstants,
    Optional<AstNode> semicolonTokenAstNode,
    Optional<List<AstNode>> enumDeclarations,
    AstNode closeBraceTokenAstNode) {

    ImmutableList.Builder<AstNode> members = ImmutableList.builder();
    if (enumConstants.isPresent()) {
      for (EnumConstantTreeImpl enumConstant : enumConstants.get()) {
        members.add(enumConstant);
      }
    }
    if (semicolonTokenAstNode.isPresent()) {
      // TODO This is a hack
      members.add(semicolonTokenAstNode.get());
    }
    if (enumDeclarations.isPresent()) {
      for (AstNode enumDeclaration : enumDeclarations.get()) {
        members.add(enumDeclaration);
      }
    }

    ClassTreeImpl result = newClassBody(Kind.ENUM, openBraceTokenAstNode, Optional.of((List<AstNode>) members.build()), closeBraceTokenAstNode);

    List<AstNode> children = Lists.newArrayList();
    children.add(enumTokenAstNode);
    result.completeDeclarationKeyword(InternalSyntaxToken.create(enumTokenAstNode));

    IdentifierTreeImpl identifier = new IdentifierTreeImpl(InternalSyntaxToken.create(identifierAstNode));
    result.completeIdentifier(identifier);
    children.add(identifier);

    if (implementsClause.isPresent()) {
      InternalSyntaxToken implementsKeyword = InternalSyntaxToken.create(implementsClause.get().first());
      QualifiedIdentifierListTreeImpl interfaces = implementsClause.get().second();
      children.add(implementsKeyword);
      children.add(interfaces);
      result.completeInterfaces(implementsKeyword, interfaces);
    }

    result.prependChildren(children);

    return result;
  }

