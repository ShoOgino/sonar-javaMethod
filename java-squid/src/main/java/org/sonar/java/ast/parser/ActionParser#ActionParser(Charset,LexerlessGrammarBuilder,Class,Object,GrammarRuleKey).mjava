  public ActionParser(Charset charset, LexerlessGrammarBuilder b, Class grammarClass, Object action, GrammarRuleKey rootRule) {
    super(null);

    List<Field> fields = Lists.newArrayList();
    Set<String> foundFields = Sets.newHashSet();

    for (Field field : AstNode.class.getDeclaredFields()) {
      if (FIELDS_TO_FIND.contains(field.getName())) {
        foundFields.add(field.getName());
      }

      if (FIELDS_TO_COPY.contains(field.getName())) {
        field.setAccessible(true);
        fields.add(field);
      }
    }

    Preconditions.checkState(foundFields.size() == FIELDS_TO_FIND.size(), "Did not find all expected fields");
    Preconditions.checkState(fields.size() == FIELDS_TO_COPY.size(), "Did not find all fields to copy");

    this.fields = fields.toArray(new Field[fields.size()]);

    this.action = action;

    this.grammarBuilderInterceptor = new GrammarBuilderInterceptor(b);
    Enhancer grammarEnhancer = new Enhancer();
    grammarEnhancer.setSuperclass(grammarClass);
    grammarEnhancer.setCallback(grammarBuilderInterceptor);

    ActionMethodInterceptor actionMethodInterceptor = new ActionMethodInterceptor(grammarBuilderInterceptor);
    Enhancer actionEnhancer = new Enhancer();
    actionEnhancer.setSuperclass(action.getClass());
    actionEnhancer.setCallback(actionMethodInterceptor);

    Object grammar = grammarEnhancer.create(
      new Class[] {GrammarBuilder.class, action.getClass()},
      new Object[] {grammarBuilderInterceptor, actionEnhancer.create()});

    for (Method method : grammarClass.getMethods()) {
      if (method.getDeclaringClass().equals(Object.class)) {
        continue;
      }

      try {
        method.invoke(grammar);
      } catch (InvocationTargetException e) {
        throw Throwables.propagate(e);
      } catch (IllegalAccessException e) {
        throw Throwables.propagate(e);
      }
    }

    b.setRootRule(rootRule);
    this.parser = new ParserAdapter<LexerlessGrammar>(charset, b.build());
  }

