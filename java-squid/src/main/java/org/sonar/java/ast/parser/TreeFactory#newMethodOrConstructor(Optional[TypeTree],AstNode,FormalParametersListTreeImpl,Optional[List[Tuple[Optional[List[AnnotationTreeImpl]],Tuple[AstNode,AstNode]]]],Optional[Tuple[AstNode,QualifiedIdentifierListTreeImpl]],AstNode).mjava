  private MethodTreeImpl newMethodOrConstructor(
    Optional<TypeTree> type, AstNode identifierAstNode, FormalParametersListTreeImpl parameters,
    Optional<List<Tuple<Optional<List<AnnotationTreeImpl>>, Tuple<AstNode, AstNode>>>> annotatedDimensions,
    Optional<Tuple<AstNode, QualifiedIdentifierListTreeImpl>> throwsClause,
    AstNode blockOrSemicolon) {

    IdentifierTreeImpl identifier = new IdentifierTreeImpl(InternalSyntaxToken.create(identifierAstNode));

    ArrayTypeTreeImpl nestedDimensions = newArrayTypeTreeWithAnnotations(annotatedDimensions);
    TypeTree actualType;
    if (type.isPresent()) {
      actualType = applyDim(type.get(), nestedDimensions);
    } else {
      actualType = null;
    }
    BlockTreeImpl block = null;
    InternalSyntaxToken semicolonToken = null;
    if (blockOrSemicolon.is(Tree.Kind.BLOCK)) {
      block = (BlockTreeImpl) blockOrSemicolon;
    } else {
      semicolonToken = InternalSyntaxToken.create(blockOrSemicolon);
    }

    InternalSyntaxToken throwsToken = null;
    List<TypeTree> throwsClauses = ImmutableList.<TypeTree>of();
    if (throwsClause.isPresent()) {
      throwsToken = InternalSyntaxToken.create(throwsClause.get().first());
      throwsClauses = throwsClause.get().second();
    }

    MethodTreeImpl result = new MethodTreeImpl(
      actualType,
      identifier,
      parameters,
      throwsToken,
      throwsClauses,
      block,
      semicolonToken);

    List<AstNode> children = Lists.newArrayList();
    if (type.isPresent()) {
      children.add((AstNode) type.get());
    }
    children.add(identifier);
    children.add(parameters);
    if (nestedDimensions != null) {
      children.add(nestedDimensions);
    }
    if (throwsClause.isPresent()) {
      children.add(throwsClause.get().first());
      children.add(throwsClause.get().second());
    }
    if (block != null) {
      children.add(block);
    } else {
      children.add(semicolonToken);
    }

    result.prependChildren(children);

    return result;
  }

