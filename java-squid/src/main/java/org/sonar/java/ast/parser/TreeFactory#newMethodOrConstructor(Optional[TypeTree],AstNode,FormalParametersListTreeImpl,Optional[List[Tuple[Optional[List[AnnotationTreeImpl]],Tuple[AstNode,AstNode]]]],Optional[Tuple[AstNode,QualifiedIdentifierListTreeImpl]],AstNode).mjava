  private MethodTreeImpl newMethodOrConstructor(
    Optional<TypeTree> type, AstNode identifierAstNode, FormalParametersListTreeImpl parameters,
    Optional<List<Tuple<Optional<List<AnnotationTreeImpl>>, Tuple<AstNode, AstNode>>>> annotatedDimensions,
    Optional<Tuple<AstNode, QualifiedIdentifierListTreeImpl>> throwsClause,
    AstNode blockOrSemicolon) {

    IdentifierTreeImpl identifier = new IdentifierTreeImpl(InternalSyntaxToken.create(identifierAstNode));

    TypeTree actualType;
    if (type.isPresent()) {
      actualType = applyDim(type.get(), annotatedDimensions.isPresent() ? annotatedDimensions.get().size() : 0);
    } else {
      actualType = null;
    }
    BlockTreeImpl block = null;
    SyntaxToken semicolonToken = null;
    if (blockOrSemicolon.is(Tree.Kind.BLOCK)) {
      block = (BlockTreeImpl) blockOrSemicolon;
    } else {
      semicolonToken = InternalSyntaxToken.create(blockOrSemicolon);
    }

    MethodTreeImpl result = new MethodTreeImpl(
      actualType,
      identifier,
      parameters,
      throwsClause.isPresent() ? (List<TypeTree>) throwsClause.get().second() : ImmutableList.<TypeTree>of(),
      block,
      semicolonToken);

    List<AstNode> children = Lists.newArrayList();
    if (type.isPresent()) {
      children.add((AstNode) type.get());
    }
    children.add(identifier);
    children.add(parameters);
    if (annotatedDimensions.isPresent()) {
      for (Tuple<Optional<List<AnnotationTreeImpl>>, Tuple<AstNode, AstNode>> annotatedDimension : annotatedDimensions.get()) {
        if (annotatedDimension.first().isPresent()) {
          for (AnnotationTreeImpl annotation : annotatedDimension.first().get()) {
            children.add(annotation);
          }
        }
        children.add(annotatedDimension.second());
      }
    }
    if (throwsClause.isPresent()) {
      children.add(throwsClause.get().first());
      children.add(throwsClause.get().second());
    }
    children.add(blockOrSemicolon);

    result.prependChildren(children);

    return result;
  }

