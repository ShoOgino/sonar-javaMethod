  private void applyActions(AstNode astNode) {
    AstNode[] children = astNode.getChildren().toArray(new AstNode[astNode.getChildren().size()]);
    for (AstNode childAstNode : children) {
      applyActions(childAstNode);
    }

    Method method = grammarBuilderInterceptor.actionForRuleKey(astNode.getType());
    if (method != null) {
      children = astNode.getChildren().toArray(new AstNode[astNode.getChildren().size()]);
      Object[] convertedChildren = convertTypes(children);

      Preconditions.checkState(
        convertedChildren.length == method.getParameterTypes().length,
        "Argument mismatch! Expected: " + method.getParameterTypes().length + " parameters, but got: " + convertedChildren.length + "\n" +
          AstXmlPrinter.print(astNode));

      try {
        List<Token> oldTokens = verifyAssertions ? astNode.getTokens() : Collections.<Token>emptyList();
        AstNode typedNode = (AstNode) method.invoke(action, convertedChildren);
        replaceAstNode(astNode, typedNode, oldTokens);
      } catch (InvocationTargetException e) {
        throw Throwables.propagate(e);
      } catch (IllegalAccessException e) {
        throw Throwables.propagate(e);
      }
    }

    if (grammarBuilderInterceptor.hasMethodForRuleKey(astNode.getType())) {
      List<Token> oldTokens = verifyAssertions ? astNode.getTokens() : Collections.<Token>emptyList();
      children = astNode.getChildren().toArray(new AstNode[astNode.getChildren().size()]);
      Preconditions.checkState(children.length == 1, "Unexpected number of children: " + children.length);
      AstNode typedNode = children[0];
      replaceAstNode(astNode, typedNode, oldTokens);
    }
  }

