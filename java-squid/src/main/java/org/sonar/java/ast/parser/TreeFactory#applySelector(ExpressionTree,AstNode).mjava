  private ExpressionTree applySelector(ExpressionTree expression, AstNode selectorNode) {
    JavaTreeMaker.checkType(selectorNode, JavaGrammar.SELECTOR);

    AstNode identifierAstNode = selectorNode.getFirstChild(JavaKeyword.THIS);
    AstNode node = selectorNode;
    if (identifierAstNode == null && selectorNode.hasDirectChildren(JavaGrammar.MEMBER_SELECT_OR_METHOD_INVOCATION)) {
      node = selectorNode.getFirstChild(JavaGrammar.MEMBER_SELECT_OR_METHOD_INVOCATION);
      identifierAstNode = node.getFirstChild(JavaTokenType.IDENTIFIER);
    } else if (selectorNode.hasDirectChildren(JavaGrammar.SUPER_SUFFIX)) {
      identifierAstNode = selectorNode.getFirstChild(JavaGrammar.SUPER_SUFFIX).getFirstChild(JavaKeyword.SUPER);
    }

    if (identifierAstNode != null) {
      InternalSyntaxToken identifierToken = InternalSyntaxToken.create(identifierAstNode);
      IdentifierTreeImpl identifier = new IdentifierTreeImpl(identifierToken);

      List<AstNode> children = Lists.newArrayList();
      children.add((AstNode) expression);
      children.add(selectorNode.getFirstChild(JavaPunctuator.DOT));
      if (node.hasDirectChildren(JavaGrammar.NON_WILDCARD_TYPE_ARGUMENTS)) {
        children.add(node.getFirstChild(JavaGrammar.NON_WILDCARD_TYPE_ARGUMENTS));
      }
      children.add(identifier);

      ExpressionTree result = new MemberSelectExpressionTreeImpl(expression, identifier,
        children.toArray(new AstNode[0]));

      if (node.hasDirectChildren(JavaGrammar.ARGUMENTS)) {
        ArgumentListTreeImpl arguments = (ArgumentListTreeImpl) node.getFirstChild(JavaGrammar.ARGUMENTS);
        result = new MethodInvocationTreeImpl(result, arguments,
          (AstNode) result, arguments);
      } else if (selectorNode.hasDirectChildren(JavaGrammar.SUPER_SUFFIX)) {
        result = applySuperSuffix(result, selectorNode.getFirstChild(JavaGrammar.SUPER_SUFFIX));
      }

      return result;
    } else if (selectorNode.hasDirectChildren(JavaGrammar.EXPLICIT_GENERIC_INVOCATION)) {
      return applyExplicitGenericInvocation(expression, selectorNode.getFirstChild(JavaPunctuator.DOT), selectorNode.getFirstChild(JavaGrammar.EXPLICIT_GENERIC_INVOCATION));
    } else if (selectorNode.hasDirectChildren(JavaKeyword.NEW)) {
      AstNode innerCreatorNode = selectorNode.getFirstChild(JavaGrammar.INNER_CREATOR);
      IdentifierTreeImpl identifier = new IdentifierTreeImpl(InternalSyntaxToken.create(innerCreatorNode.getFirstChild(JavaTokenType.IDENTIFIER)));

      AstNode classCreatorRestNode = innerCreatorNode.getFirstChild(JavaGrammar.CLASS_CREATOR_REST);
      ArgumentListTreeImpl arguments = (ArgumentListTreeImpl) classCreatorRestNode.getFirstChild(JavaGrammar.ARGUMENTS);

      ClassTree classBody = null;
      if (classCreatorRestNode.hasDirectChildren(JavaGrammar.CLASS_BODY)) {
        classBody = new ClassTreeImpl(
          classCreatorRestNode,
          Tree.Kind.CLASS,
          ModifiersTreeImpl.EMPTY,
          treeMaker.classBody(classCreatorRestNode.getFirstChild(JavaGrammar.CLASS_BODY)));
      }

      List<AstNode> children = Lists.newArrayList();
      children.add((AstNode) expression);
      children.add(selectorNode.getFirstChild(JavaPunctuator.DOT));
      children.add(selectorNode.getFirstChild(JavaKeyword.NEW));
      if (selectorNode.hasDirectChildren(JavaGrammar.NON_WILDCARD_TYPE_ARGUMENTS)) {
        children.add(selectorNode.getFirstChild(JavaGrammar.NON_WILDCARD_TYPE_ARGUMENTS));
      }
      children.add(identifier);
      children.add(classCreatorRestNode);

      return new NewClassTreeImpl(
        expression, identifier, arguments, classBody,
        children.toArray(new AstNode[children.size()]));
    } else if (selectorNode.hasDirectChildren(Kind.ARRAY_ACCESS_EXPRESSION)) {
      return ((ArrayAccessExpressionTreeImpl) selectorNode.getFirstChild(Kind.ARRAY_ACCESS_EXPRESSION)).complete(expression);
    } else {
      throw new IllegalStateException(AstXmlPrinter.print(selectorNode));
    }
  }

