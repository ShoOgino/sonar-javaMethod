  public <T extends Tree> T newQualifiedIdentifier(ExpressionTree firstIdentifier, Optional<List<Tuple<InternalSyntaxToken, ExpressionTree>>> rests) {
    ExpressionTree result = firstIdentifier;

    if (rests.isPresent()) {
      for (Tuple<InternalSyntaxToken, ExpressionTree> rest : rests.get()) {
        InternalSyntaxToken dotToken = rest.first();
        if (rest.second().is(Kind.IDENTIFIER)) {
          result = new MemberSelectExpressionTreeImpl(result, dotToken, (IdentifierTreeImpl) rest.second());
        } else if (rest.second().is(Kind.PARAMETERIZED_TYPE)) {
          ParameterizedTypeTreeImpl parameterizedType = (ParameterizedTypeTreeImpl) rest.second();
          IdentifierTreeImpl identifier = (IdentifierTreeImpl) parameterizedType.type();

          result = new MemberSelectExpressionTreeImpl(result, dotToken, identifier);
          result = new ParameterizedTypeTreeImpl((TypeTree) result, (TypeArgumentListTreeImpl) parameterizedType.typeArguments());
        } else {
          throw new IllegalArgumentException();
        }
      }
      TypeTree typeTree = (TypeTree) firstIdentifier;
      // move the annotations from the first identifier to the member select or the parameterized type
      List<AnnotationTree> firstIdentifierAnnotations = typeTree.annotations();
      if (!firstIdentifierAnnotations.isEmpty()) {
        if (result.is(Tree.Kind.MEMBER_SELECT)) {
          ((MemberSelectExpressionTreeImpl) result).complete(firstIdentifierAnnotations);
        } else {
          ((ParameterizedTypeTreeImpl) result).complete(firstIdentifierAnnotations);
        }
        completeTypeTreeWithAnnotations(typeTree, ImmutableList.<AnnotationTree>of());
      }
    }

    return (T) result;
  }

