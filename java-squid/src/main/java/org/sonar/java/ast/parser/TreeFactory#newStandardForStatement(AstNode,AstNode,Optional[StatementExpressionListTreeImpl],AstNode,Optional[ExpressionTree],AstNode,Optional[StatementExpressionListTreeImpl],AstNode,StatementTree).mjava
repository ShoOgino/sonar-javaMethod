  public ForStatementTreeImpl newStandardForStatement(
    AstNode forTokenAstNode,
    AstNode openParenTokenAstNode,
    Optional<StatementExpressionListTreeImpl> forInit, AstNode forInitSemicolonTokenAstNode,
    Optional<ExpressionTree> expression, AstNode expressionSemicolonTokenAstNode,
    Optional<StatementExpressionListTreeImpl> forUpdate, AstNode closeParenTokenAstNode,
    StatementTree statement) {

    StatementExpressionListTreeImpl forInit2 = forInit.isPresent() ? forInit.get() : new StatementExpressionListTreeImpl(ImmutableList.<StatementTree>of());
    StatementExpressionListTreeImpl forUpdate2 = forUpdate.isPresent() ? forUpdate.get() : new StatementExpressionListTreeImpl(ImmutableList.<StatementTree>of());

    InternalSyntaxToken forKeyword = InternalSyntaxToken.create(forTokenAstNode);
    InternalSyntaxToken openParenToken = InternalSyntaxToken.create(openParenTokenAstNode);
    InternalSyntaxToken firstSemicolonToken = InternalSyntaxToken.create(forInitSemicolonTokenAstNode);
    InternalSyntaxToken secondSemicolonToken = InternalSyntaxToken.create(expressionSemicolonTokenAstNode);
    InternalSyntaxToken closeParenToken = InternalSyntaxToken.create(closeParenTokenAstNode);
    
    ForStatementTreeImpl result = new ForStatementTreeImpl(
      forKeyword,
      openParenToken,
      forInit2,
      firstSemicolonToken,
      expression.isPresent() ? expression.get() : null,
      secondSemicolonToken,
      forUpdate2,
      closeParenToken,
      statement);

    List<AstNode> children = Lists.newArrayList();
    children.add(forTokenAstNode);
    children.add(openParenTokenAstNode);
    children.add(forInit2);
    children.add(forInitSemicolonTokenAstNode);
    if (expression.isPresent()) {
      children.add((AstNode) expression.get());
    }
    children.add(expressionSemicolonTokenAstNode);
    children.add(forUpdate2);
    children.add(closeParenTokenAstNode);
    children.add((AstNode) statement);

    result.prependChildren(children);

    return result;
  }

