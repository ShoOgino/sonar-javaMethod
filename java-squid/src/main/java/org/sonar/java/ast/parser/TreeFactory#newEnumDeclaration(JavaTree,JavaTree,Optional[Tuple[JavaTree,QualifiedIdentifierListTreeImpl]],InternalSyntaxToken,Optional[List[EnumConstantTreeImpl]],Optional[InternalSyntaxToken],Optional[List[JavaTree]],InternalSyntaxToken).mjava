  public ClassTreeImpl newEnumDeclaration(
    JavaTree enumToken,
    JavaTree identifierToken,
    Optional<Tuple<JavaTree, QualifiedIdentifierListTreeImpl>> implementsClause,
    InternalSyntaxToken openBraceToken,
    Optional<List<EnumConstantTreeImpl>> enumConstants,
    Optional<InternalSyntaxToken> semicolonToken,
    Optional<List<JavaTree>> enumDeclarations,
    InternalSyntaxToken closeBraceToken) {
    
    List<JavaTree> members = Lists.newLinkedList();
    EnumConstantTreeImpl lastEnumConstant = null;
    if (enumConstants.isPresent()) {
      for (EnumConstantTreeImpl enumConstant : enumConstants.get()) {
        members.add(enumConstant);
        lastEnumConstant = enumConstant;
      }
    }
    if (semicolonToken.isPresent()) {
      InternalSyntaxToken semicolon = semicolonToken.get();
      // add the semicolon as endToken of the last enumConstant, or as empty statement in the enum members
      if (lastEnumConstant != null) {
        lastEnumConstant.setEndToken(semicolon);
      } else {
        members.add(newEmptyMember(semicolon));
      }
    }
    if (enumDeclarations.isPresent()) {
      for (JavaTree enumDeclaration : enumDeclarations.get()) {
        members.add(enumDeclaration);
      }
    }

    ClassTreeImpl result = newClassBody(Kind.ENUM, openBraceToken, Optional.of((List<JavaTree>) ImmutableList.<JavaTree>builder().addAll(members).build()), closeBraceToken);

    result.completeDeclarationKeyword((SyntaxToken) enumToken);

    IdentifierTreeImpl identifier = new IdentifierTreeImpl((InternalSyntaxToken) identifierToken);
    result.completeIdentifier(identifier);

    if (implementsClause.isPresent()) {
      InternalSyntaxToken implementsKeyword = (InternalSyntaxToken) implementsClause.get().first();
      QualifiedIdentifierListTreeImpl interfaces = implementsClause.get().second();
      result.completeInterfaces(implementsKeyword, interfaces);
    }

    return result;
  }

