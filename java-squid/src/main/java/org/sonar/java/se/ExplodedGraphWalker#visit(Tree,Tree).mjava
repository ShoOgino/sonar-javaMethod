  private void visit(Tree tree, @Nullable Tree terminator) {
    LOG.debug("visiting node " + tree.kind().name() + " at line " + ((JavaTree) tree).getLine());
    if (!checkerDispatcher.executeCheckPreStatement(tree)) {
      // Some of the check pre statement sink the execution on this node.
      return;
    }
    switch (tree.kind()) {
      case METHOD_INVOCATION:
        MethodInvocationTree mit = (MethodInvocationTree) tree;
        setSymbolicValueOnFields(mit);
        // unstack arguments and method identifier

        programState = programState.unstackValue(mit.arguments().size() + 1).a;
        logState(mit);
        programState = programState.stackValue(constraintManager.createSymbolicValue(mit));
        break;
      case LABELED_STATEMENT:
      case SWITCH_STATEMENT:
      case EXPRESSION_STATEMENT:
      case PARENTHESIZED_EXPRESSION:
        throw new IllegalStateException("Cannot appear in CFG: " + tree.kind().name());
      case VARIABLE:
        VariableTree variableTree = (VariableTree) tree;
        ExpressionTree initializer = variableTree.initializer();
        if (initializer == null) {
          SymbolicValue sv = null;
          if (terminator != null && terminator.is(Tree.Kind.FOR_EACH_STATEMENT)) {
            sv = constraintManager.createSymbolicValue(variableTree);
          } else if (variableTree.type().symbolType().is("boolean")) {
            sv = SymbolicValue.FALSE_LITERAL;
          } else if (!variableTree.type().symbolType().isPrimitive()) {
            sv = SymbolicValue.NULL_LITERAL;
          }
          if (sv != null) {
            programState = programState.put(variableTree.symbol(), sv);
          }
        } else {

          Pair<ProgramState, List<SymbolicValue>> unstack = programState.unstackValue(1);
          programState = unstack.a;
          programState = programState.put(variableTree.symbol(), unstack.b.get(0));
        }
        break;
      case TYPE_CAST:
        TypeCastTree typeCast = (TypeCastTree) tree;
        Type type = typeCast.type().symbolType();
        if (type.isPrimitive()) {

          Pair<ProgramState, List<SymbolicValue>> unstack = programState.unstackValue(1);
          programState = unstack.a;
          programState = programState.stackValue(constraintManager.createSymbolicValue(typeCast.expression()));
        }
        break;
      case ASSIGNMENT:
        ExpressionTree variable = ((AssignmentExpressionTree) tree).variable();
        if (variable.is(Tree.Kind.IDENTIFIER)) {
          // FIXME restricted to identifiers for now.

          Pair<ProgramState, List<SymbolicValue>> unstack = programState.unstackValue(2);
          SymbolicValue value = unstack.b.get(1);
          programState = unstack.a;
          programState = programState.put(((IdentifierTree) variable).symbol(), value);
          programState = programState.stackValue(value);
        }
        break;
      case ARRAY_ACCESS_EXPRESSION:
        ArrayAccessExpressionTree arrayAccessExpressionTree = (ArrayAccessExpressionTree) tree;
        // unstack expression and dimension

        Pair<ProgramState, List<SymbolicValue>> unstack = programState.unstackValue(2);
        programState = unstack.a;
        programState = programState.stackValue(constraintManager.createSymbolicValue(arrayAccessExpressionTree));
        break;
      case NEW_ARRAY:
        NewArrayTree newArrayTree = (NewArrayTree) tree;

        programState = programState.unstackValue(newArrayTree.initializers().size()).a;
        SymbolicValue svNewArray = constraintManager.createSymbolicValue(newArrayTree);
        programState = programState.stackValue(svNewArray);
        programState = svNewArray.setSingleConstraint(programState, NullConstraint.NOT_NULL);
        break;
      case NEW_CLASS:
        NewClassTree newClassTree = (NewClassTree) tree;

        programState = programState.unstackValue(newClassTree.arguments().size()).a;
        SymbolicValue svNewClass = constraintManager.createSymbolicValue(newClassTree);
        programState = programState.stackValue(svNewClass);
        programState = svNewClass.setSingleConstraint(programState, NullConstraint.NOT_NULL);
        break;
      case MULTIPLY:
      case DIVIDE:
      case REMAINDER:
      case PLUS:
      case MINUS:
      case LEFT_SHIFT:
      case RIGHT_SHIFT:
      case UNSIGNED_RIGHT_SHIFT:
      case AND:
      case XOR:
      case OR:
      case GREATER_THAN:
      case GREATER_THAN_OR_EQUAL_TO:
      case LESS_THAN:
      case LESS_THAN_OR_EQUAL_TO:
      case EQUAL_TO:
      case NOT_EQUAL_TO:
        // Consume two and produce one SV.

        Pair<ProgramState, List<SymbolicValue>> unstackBinary = programState.unstackValue(2);
        programState = unstackBinary.a;
        SymbolicValue symbolicValue = constraintManager.createSymbolicValue(tree);
        symbolicValue.computedFrom(unstackBinary.b);
        programState = programState.stackValue(symbolicValue);
        break;
      case POSTFIX_INCREMENT:
      case POSTFIX_DECREMENT:
      case PREFIX_INCREMENT:
      case PREFIX_DECREMENT:
      case UNARY_MINUS:
      case UNARY_PLUS:
      case BITWISE_COMPLEMENT:
      case LOGICAL_COMPLEMENT:
      case INSTANCE_OF:
        // consume one and produce one

        Pair<ProgramState, List<SymbolicValue>> unstackUnary = programState.unstackValue(1);
        programState = unstackUnary.a;
        SymbolicValue unarySymbolicValue = constraintManager.createSymbolicValue(tree);
        unarySymbolicValue.computedFrom(unstackUnary.b);
        programState = programState.stackValue(unarySymbolicValue);
        break;
      case IDENTIFIER:
        Symbol symbol = ((IdentifierTree) tree).symbol();
        SymbolicValue value = programState.getValue(symbol);
        if (value == null) {
          value = constraintManager.createSymbolicValue(tree);
          programState = programState.put(symbol, value);
        }
        programState = programState.stackValue(value);
        break;
      case MEMBER_SELECT:
        MemberSelectExpressionTree mse = (MemberSelectExpressionTree) tree;
        if (!"class".equals(mse.identifier().name())) {

          Pair<ProgramState, List<SymbolicValue>> unstackMSE = programState.unstackValue(1);
          programState = unstackMSE.a;
        }
        SymbolicValue mseValue = constraintManager.createSymbolicValue(tree);
        programState = programState.stackValue(mseValue);
        break;
      case INT_LITERAL:
      case LONG_LITERAL:
      case FLOAT_LITERAL:
      case DOUBLE_LITERAL:
      case BOOLEAN_LITERAL:
      case CHAR_LITERAL:
      case STRING_LITERAL:
      case NULL_LITERAL:
        SymbolicValue val = constraintManager.evalLiteral((LiteralTree) tree);
        programState = programState.stackValue(val);
        break;
      case LAMBDA_EXPRESSION:
      case METHOD_REFERENCE:
        programState = programState.stackValue(constraintManager.createSymbolicValue(tree));
        break;
      default:
    }

    checkerDispatcher.executeCheckPostStatement(tree);
    clearStack(tree);
  }

