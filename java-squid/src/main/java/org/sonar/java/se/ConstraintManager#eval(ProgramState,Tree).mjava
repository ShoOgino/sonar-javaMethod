  public SymbolicValue eval(ProgramState programState, Tree node) {
    Tree syntaxNode = skipTrivial(node);
    switch (syntaxNode.kind()) {
      case NULL_LITERAL:
        return SymbolicValue.NULL_LITERAL;
      case BOOLEAN_LITERAL:
        boolean value = Boolean.parseBoolean(((LiteralTree) syntaxNode).value());
        if (value) {
          return SymbolicValue.TRUE_LITERAL;
        }
        return SymbolicValue.FALSE_LITERAL;
      case VARIABLE:
        SymbolicValue variableResult = programState.values.get(((VariableTree) syntaxNode).symbol());
        if (variableResult != null) {
          // symbolic value associated with local variable
          return variableResult;
        }
        break;
      case IDENTIFIER:
        SymbolicValue identifierResult = programState.values.get(((IdentifierTree) syntaxNode).symbol());
        if (identifierResult != null) {
          // symbolic value associated with local variable
          return identifierResult;
        }
        break;
      case LOGICAL_COMPLEMENT:
        UnaryExpressionTree unaryExpressionTree = (UnaryExpressionTree) syntaxNode;
        SymbolicValue val = eval(programState, unaryExpressionTree.expression());
        if (SymbolicValue.FALSE_LITERAL.equals(val)) {
          return SymbolicValue.TRUE_LITERAL;
        } else if (val.equals(SymbolicValue.TRUE_LITERAL)) {
          return SymbolicValue.FALSE_LITERAL;
        }
        // if not tied to a concrete value, create symbolic value with no constraint for now.
        // TODO : create constraint between expression and created symbolic value
      default:
    }
    return createSymbolicValue(syntaxNode);
  }

