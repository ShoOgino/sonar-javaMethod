  private void handleBlockExit(ExplodedGraph.ProgramPoint programPosition) {
    CFG.Block block = programPosition.block;
    if (block.terminator() != null) {
      switch (block.terminator().kind()) {
        case IF_STATEMENT:
          handleBranch(block, ((IfStatementTree) block.terminator()).condition());
          return;
        case CONDITIONAL_OR:
        case CONDITIONAL_AND:
          handleBranch(block, ((BinaryExpressionTree) block.terminator()).leftOperand());
          return;
        case CONDITIONAL_EXPRESSION:
          handleBranch(block, ((ConditionalExpressionTree) block.terminator()).condition());
          return;
        case FOR_STATEMENT:
          ForStatementTree forStatement = (ForStatementTree) block.terminator();
          if (forStatement.condition() != null) {
            handleBranch(block, forStatement.condition(), false);
            return;
          }
          break;
        case WHILE_STATEMENT:
          ExpressionTree condition = ((WhileStatementTree) block.terminator()).condition();
          handleBranch(block, condition, !condition.is(Tree.Kind.BOOLEAN_LITERAL));
          return;
        case SYNCHRONIZED_STATEMENT:
          resetFieldValues(null);
          break;
      }
    }
    // unconditional jumps, for-statement, switch-statement, synchronized:
    for (CFG.Block successor : block.successors()) {
      enqueue(new ExplodedGraph.ProgramPoint(successor, 0), programState);
    }
  }

