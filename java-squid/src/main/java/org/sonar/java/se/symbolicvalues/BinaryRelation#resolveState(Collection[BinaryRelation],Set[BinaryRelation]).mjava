  @CheckForNull
  protected RelationState resolveState(Collection<BinaryRelation> knownRelations, Set<BinaryRelation> usedRelations) {
    //relation on same operand
    if(leftOp.equals(rightOp)) {
      switch (kind) {
        case EQUAL:
        case GREATER_THAN_OR_EQUAL:
        case LESS_THAN_OR_EQUAL:
        case METHOD_EQUALS:
          return RelationState.FULFILLED;
        case NOT_EQUAL:
        case GREATER_THAN:
        case LESS_THAN:
        case NOT_METHOD_EQUALS:
          return RelationState.UNFULFILLED;
        default:
          throw new IllegalStateException("Binary relation kind unsupported" + kind);
      }
    }
    if (knownRelations.isEmpty()) {
      return RelationState.UNDETERMINED;
    }
    if (usedRelations.size() > 200) {
      throw new TransitiveRelationExceededException();
    }
    for (BinaryRelation relation : knownRelations) {
      RelationState result = relation.implies(this);
      if (result.isDetermined()) {
        return result;
      }
      usedRelations.add(relation);
      usedRelations.add(relation.symmetric());
    }
    Collection<BinaryRelation> transitiveReduction = transitiveReduction(knownRelations, usedRelations);
    if (transitiveReduction.isEmpty()) {
      // If no new combination, try with the symmetric (because transitive reduction only checks the operand on the left side.
      transitiveReduction = symmetric().transitiveReduction(knownRelations, usedRelations);
    }
    return resolveState(transitiveReduction, usedRelations);
  }

