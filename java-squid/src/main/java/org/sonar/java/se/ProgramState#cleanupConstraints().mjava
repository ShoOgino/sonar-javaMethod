  public ProgramState cleanupConstraints() {
    PMap<SymbolicValue, Constraint> newConstraints = constraints;
    PMap<SymbolicValue, Integer> newReferences = references;
    boolean newProgramState = false;
    for (Iterator<Map.Entry<SymbolicValue, Constraint>> iter = newConstraints.entriesIterator(); iter.hasNext();) {
      Map.Entry<SymbolicValue, Constraint> next = iter.next();
      SymbolicValue symbolicValue = next.getKey();
      if (!isReachable(symbolicValue, newReferences) && isDisposable(symbolicValue, next.getValue()) && !inStack(stack, symbolicValue)) {
        if (!newProgramState) {
          newProgramState = true;
        }
        newConstraints = newConstraints.remove(symbolicValue);
        newReferences = newReferences.remove(symbolicValue);
      }
    }
    return newProgramState ? new ProgramState(values, newReferences, newConstraints, visitedPoints, stack) : this;
  }

