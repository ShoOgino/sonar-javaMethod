  private void resolveQualifiedIdentifier(Tree tree) {
    final Resolve.Env env = semanticModel.getEnv(tree);
    class FQV extends BaseTreeVisitor {
      private Symbol site;

      @Override
      public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {
        scan(tree.expression());
        String name = tree.identifier().name();
        if (JavaKeyword.CLASS.getValue().equals(name)) {
          registerType(tree, symbols.classType);
          return;
        }
        if (site.kind >= Symbol.ERRONEOUS) {
          registerType(tree, symbols.unknownType);
          return;
        }
        if (site.kind == Symbol.VAR) {
          Type siteType = ((Symbol.VariableSymbol) site).type;
          // TODO avoid null
          if (siteType == null) {
            registerType(tree, symbols.unknownType);
            return;
          }
          site = resolve.findIdentInType(env, siteType.symbol, name, Symbol.VAR | Symbol.TYP);
        } else if (site.kind == Symbol.TYP) {
          site = resolve.findIdentInType(env, (Symbol.TypeSymbol) site, name, Symbol.VAR | Symbol.TYP);
        } else if (site.kind == Symbol.PCK) {
          site = resolve.findIdentInPackage(site, name, Symbol.TYP | Symbol.PCK);
        } else if (site.kind == Symbol.MTH) {
          // FIXME(Godin): Unhandled case! For example see org.sonar.duplications.java.JavaStatementBuilder , which uses fluent interface
          registerType(tree, symbols.unknownType);
          return;
        } else {
          throw new IllegalStateException("Unexpected Symbol kind: " + site.kind);
        }
        associateReference(tree.identifier(), site);
        registerType(tree, getTypeOfSymbol(site));
      }

      @Override
      public void visitArrayType(ArrayTypeTree tree) {
        super.visitArrayType(tree);
        registerType(tree, new Type.ArrayType(getType(tree.type()), symbols.arrayClass));
      }

      @Override
      public void visitArrayAccessExpression(ArrayAccessExpressionTree tree) {
        super.visitArrayAccessExpression(tree);
        Type arrayType = getType(tree.expression());
        if (arrayType != null && arrayType.tag == Type.ARRAY) {
          site = arrayType.symbol;
          registerType(tree, ((Type.ArrayType) arrayType).elementType);
        } else {
          registerType(tree, symbols.unknownType);
        }
      }

      @Override
      public void visitIdentifier(IdentifierTree tree) {
        site = resolve.findIdent(semanticModel.getEnv(tree), tree.name(), Symbol.VAR | Symbol.TYP | Symbol.PCK);
        associateReference(tree, site);
        registerType(tree, getTypeOfSymbol(site));
      }

      @Override
      public void visitLiteral(LiteralTree tree) {
        Type literalType = typesOfLiterals.get(((JavaTree) tree).getKind());
        site = literalType.symbol;
        registerType(tree, literalType);
      }

      @Override
      public void visitPrimitiveType(PrimitiveTypeTree tree) {
        site = resolve.findIdent(semanticModel.getEnv(tree), tree.keyword().text(), Symbol.TYP);
        registerType(tree, site.type);
      }
    }
    FQV visitor = new FQV();
    tree.accept(visitor);
  }

