  public void complete(Symbol.TypeSymbol symbol) {
    Resolve.Env env = semanticModel.getEnv(symbol);

    if ((symbol.flags() & Flags.INTERFACE) == 0) {
      // If this is a class, enter symbols for "this" and "super".
      symbol.members.enter(new Symbol.VariableSymbol(Flags.FINAL, "this", symbol.type, symbol));
      // TODO super
    }

    if ("".equals(symbol.name)) {
      // Anonymous Class Declaration
      ((Type.ClassType) symbol.type).interfaces = ImmutableList.of();
      return;
    }

    ClassTree tree = (ClassTree) semanticModel.getTree(symbol);
    Tree superClassTree = tree.superClass();
    if (superClassTree != null && (superClassTree.is(Tree.Kind.MEMBER_SELECT) || superClassTree.is(Tree.Kind.IDENTIFIER))) {
      ((Type.ClassType) symbol.type).supertype = resolveType(env, superClassTree).type;
      checkHierarchyCycles(symbol.type);
    } else {
      // TODO superclass is java.lang.Object or java.lang.Enum or java.lang.Annotation
      if (tree.is(Tree.Kind.ENUM)) {

      } else if (tree.is(Tree.Kind.INTERFACE)) {
        //JLS8 9.1.3 : While every class is an extension of class Object, there is no single interface of which all interfaces are extensions.

      } else if (tree.is(Tree.Kind.ANNOTATION)) {
        //JLS8 9.6 : The direct superinterface of every annotation type is java.lang.annotation.Annotation.

      } else if (tree.is(Tree.Kind.CLASS)) {

      }

    }

    ImmutableList.Builder<Type> interfaces = ImmutableList.builder();
    for (Tree interfaceTree : tree.superInterfaces()) {
      Type interfaceType = castToTypeIfPossible(resolveType(env, interfaceTree));
      if (interfaceType != null) {
        interfaces.add(interfaceType);
      }
    }
    // TODO interface of AnnotationType is java.lang.annotation.Annotation
    ((Type.ClassType) symbol.type).interfaces = interfaces.build();
  }

