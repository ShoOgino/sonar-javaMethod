  /**
   * @param symbol    candidate
   * @param bestSoFar previously found best match
   */
  private Symbol selectBest(Env env, Symbol.TypeSymbol site, List<Type> argTypes, Symbol symbol, Symbol bestSoFar, boolean autoboxing) {
    // TODO get rid of null check
    if (symbol.kind >= Symbol.ERRONEOUS || !isInheritedIn(symbol, site) || symbol.type == null) {
      return bestSoFar;
    }
    boolean isVarArgs = ((Symbol.MethodSymbol) symbol).isVarArgs();
    if (!isArgumentsAcceptable(argTypes, ((Type.MethodType) symbol.type).argTypes, isVarArgs, autoboxing)) {
      return bestSoFar;
    }
    // TODO ambiguity, errors, ...
    if (!isAccessible(env, site, symbol)) {
      return new AccessErrorSymbol(symbol, symbols.unknownType);
    }
    Symbol mostSpecific = selectMostSpecific(symbol, bestSoFar, argTypes);
    if (mostSpecific.isKind(Symbol.AMBIGUOUS)) {
      //same signature, we keep the first symbol found (overrides the other one).
      mostSpecific = bestSoFar;
    }
    return mostSpecific;
  }

