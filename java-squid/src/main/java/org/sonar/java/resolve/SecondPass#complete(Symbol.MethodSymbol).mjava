  private void complete(Symbol.MethodSymbol symbol) {
    MethodTree methodTree = (MethodTree) semanticModel.getTree(symbol);
    Resolve.Env env = semanticModel.getEnv(symbol);

    ImmutableList.Builder<Symbol.TypeSymbol> thrown = ImmutableList.builder();
    for (ExpressionTree throwClause : methodTree.throwsClauses()) {
      Type thrownType = resolveType(env, throwClause);
      if (thrownType != null) {
        ((AbstractTypedTree) throwClause).setType(thrownType);
        thrown.add(((Type.ClassType) thrownType).symbol);
      }
    }
    symbol.thrown = thrown.build();

    if ("<init>".equals(symbol.name)) {
      // no return type for constructor
      return;
    }
    Type type = resolveType(env, methodTree.returnType());
    if (type != null) {
      if(type.isTagged(Type.CLASS)) {
        symbol.type = ((Type.ClassType) type).symbol;
      } else if(type.isTagged(Type.ARRAY)) {
        symbol.type = symbols.arrayClass;
      }
    }
  }

