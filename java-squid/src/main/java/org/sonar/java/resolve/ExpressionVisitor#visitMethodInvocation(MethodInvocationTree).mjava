  @Override
  public void visitMethodInvocation(MethodInvocationTree tree) {
    Tree methodSelect = tree.methodSelect();
    Resolve.Env env = semanticModel.getEnv(tree);
    IdentifierTree identifier;
    Type type;
    String name;
    if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree mset = (MemberSelectExpressionTree) methodSelect;
      scan(mset.expression());
      type = getType(mset.expression());
      identifier = mset.identifier();
    } else if (methodSelect.is(Tree.Kind.IDENTIFIER)) {
      type = env.enclosingClass.type;
      identifier = (IdentifierTree) methodSelect;
    } else {
      throw new IllegalStateException("Method select in method invocation is not of the expected type " + methodSelect);
    }
    scan(tree.typeArguments());
    scan(tree.arguments());
    name = identifier.name();
    if (type == null) {
      type = symbols.unknownType;
    }
    Symbol symbol = resolve.findMethod(env, type.symbol, name, ImmutableList.<Type>of());
    associateReference(identifier, symbol);
    type = getTypeOfSymbol(symbol);
    //Register return type for method invocation.
    //TODO register method type for method select ?
    if (type == null || symbol.kind >= Symbol.ERRONEOUS) {
      registerType(tree, symbols.unknownType);
    } else {
      registerType(tree, ((Symbol.MethodSymbol) symbol).getReturnType().getType());
    }
  }

