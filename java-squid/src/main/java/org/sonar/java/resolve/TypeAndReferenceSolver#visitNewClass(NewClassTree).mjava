  @Override
  public void visitNewClass(NewClassTree tree) {
    if (tree.enclosingExpression() != null) {
      resolveAs(tree.enclosingExpression(), Symbol.VAR);
    }
    Resolve.Env newClassEnv = semanticModel.getEnv(tree);
    resolveAs(tree.identifier(), Symbol.TYP, newClassEnv, false);
    resolveAs(tree.typeArguments(), Symbol.TYP);
    resolveAs(tree.arguments(), Symbol.VAR);
    NewClassTreeImpl newClassTreeImpl = (NewClassTreeImpl) tree;
    resolveConstructorSymbol(newClassTreeImpl.getConstructorIdentifier(), newClassEnv, getParameterTypes(tree.arguments()));
    if (tree.classBody() != null) {
      Type.ClassType anonymousClassType = symbols.unknownType;
      Type type = ((AbstractTypedTree) tree.identifier()).getSymbolType();
      Symbol.TypeSymbol symbol = ((ClassTreeImpl) tree.classBody()).getSymbol();
      if (symbol != null) {
        anonymousClassType = (Type.ClassType) symbol.type;
        if (type.getSymbol().isFlag(Flags.INTERFACE)) {
          anonymousClassType.interfaces = ImmutableList.of(type);
          anonymousClassType.supertype = symbols.objectType;
        } else {
          anonymousClassType.supertype = type;
          anonymousClassType.interfaces = ImmutableList.of();
        }
      }
      scan(tree.classBody());
      registerType(tree, anonymousClassType);
    } else {
      registerType(tree, getType(tree.identifier()));
    }
  }

