  @Override
  public void visitNewClass(NewClassTree tree) {
    if (tree.enclosingExpression() != null) {
      resolveAs(tree.enclosingExpression(), JavaSymbol.VAR);
    }
    Resolve.Env newClassEnv = semanticModel.getEnv(tree);
    resolveAs(tree.identifier(), JavaSymbol.TYP, newClassEnv, false);
    resolveAs(tree.typeArguments(), JavaSymbol.TYP);
    resolveAs(tree.arguments(), JavaSymbol.VAR);
    NewClassTreeImpl newClassTreeImpl = (NewClassTreeImpl) tree;
    resolveConstructorSymbol(newClassTreeImpl.getConstructorIdentifier(), newClassEnv, getParameterTypes(tree.arguments()));
    if (tree.classBody() != null) {
      JavaType.ClassJavaType anonymousClassType = symbols.unknownType;
      JavaType type = ((AbstractTypedTree) tree.identifier()).getSymbolType();
      JavaSymbol.TypeJavaSymbol symbol = (JavaSymbol.TypeJavaSymbol) tree.classBody().symbol();
      if (symbol != null) {
        anonymousClassType = (JavaType.ClassJavaType) symbol.type;
        if (type.getSymbol().isFlag(Flags.INTERFACE)) {
          anonymousClassType.interfaces = ImmutableList.of(type);
          anonymousClassType.supertype = symbols.objectType;
        } else {
          anonymousClassType.supertype = type;
          anonymousClassType.interfaces = ImmutableList.of();
        }
      }
      scan(tree.classBody());
      registerType(tree, anonymousClassType);
    } else {
      registerType(tree, getType(tree.identifier()));
    }
  }

